<HTML>
<HEAD>
<TITLE>WHDLoad programozása</TITLE>
<meta name="DC.Language" content="hu">
<meta http-equiv="content-language" content="hu">
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2">
<!-- $Id: howto.html 1.3 2009/02/05 20:38:15 wepl Exp wepl $ -->
</HEAD>
<BODY>
<h3>Sematikus végrehajtási folyamat</h3>
<p>A következõ táblázat mutatja a program futását amikor a WHDLoad installált program
végre lesz hajtva. Remélem segít megérteni a WHDLoad mûködését és azt, hogy
hogyan mûködik együtt a WHDLoad, a Slave és az installált program.</p>
<table cellpadding=3>
  <tr>
    <td valign=top>A FELHASZNÁLÓ</td>
    <td>
      <ul>
        <li>elindítja a demót vagy a játékot az ikonjára klikkelve vagy parancssorból indítva
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>Az Operációs Rendszer</td>
    <td valign=top>
      <ul>
        <li>betölti a WHDLoad programot és elindítja
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>WHDLoad</td>
    <td>
      <ul>
        <li>ellenõrzi a szoftver és hardver környezetet
        <li>betölti és ellenõrzi a Slave-et
        <li>lefoglalja az installált programhoz szükséges memóriát
        <li>ha a <a href="opt.html#Preload">Preload/S</a> be van kapcsolva,
betölti a lemez képmásokat és a fájlokat a memóriába (ha van elég)
        <li>leállítja a rendszert (kikapcsolja a multitask-ot és a megszakításokat, átkapcsolja a grafikus hardvert OCS módba, minden hardvert
kezdõállapotba hoz)
        <li>átugrik a Slave-re
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>Slave</td>
    <td>
      <ul>
        <li>betölti az insatllált program fõ indítóját egy WHDLoad funkció
segítségével (pl. <a
            href="../autodoc.html#resload_DiskLoad">resload_DiskLoad</a> vagy <a
            href="../autodoc.html#resload_LoadFile">resload_LoadFile</a>)
        <li>kijavítja a fõ indítót (hogy a program a Slave-en keresztül töltse
be az adatokat, kompatibilitási problémák, engedélyezi a kilépést
        <li>meghívja a fõ indítót
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>Installált program</td>
    <td>
      <ul>
        <li>teszi a dolgát
        <li>adatok betöltésénél meghívja a Slave-et (mert a Slave már
módosította hogy ezt tegye), és Slave meghívja a WHDLoad-tot, és a WHDLoad
részben engedélyezi a rendszernek az adatok betöltését (csak akkor ha az adat
nem <a href="opt.html#Preload">Preload</a>), aztán visszatér, visszatér és az
installált program fut tovább
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>A FELHASZNÁLÓ</td>
    <td>
      <ul>
        <li>kilép a programból a <a href="opt.html#QuitKey">QuitKey</a> megnyomásával
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>Slave</td>
    <td>
      <ul>
        <li>visszatér a WHDLoad-hoz a <a href="../autodoc.html#resload_Abort">resload_Abort</a>
funkcióval
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>WHDLoad</td>
    <td>
      <ul>
        <li>engedélyezi a rendszert (visszaálítja a hardver regisztereket,
képernyõt és memóriát)
        <li>felszabadítja az összes lefoglalt erõforrást
        <li>visszatér a rendszerbe
      </ul>
    </td>
  </tr>
</table>
<h3>Hogyan kell installálni egy egyszerû egylemezes sávtöltõst</h3>
Ez egy nagyon kicsi és rövid lépésenkénti útmutató ahhoz, hogy hogyan lehet a
WHDLoad segítségével installálót készíteni. Az útmutaó egy ideális egyszerû
esetet vesz alapul. A valós világban ilyen valószinûleg soha nem fog
elõfordulni. A speciális esetekre és problémákra olvasd el az ezt követõ
fejezeteket.
<ol>
  <li>Elõkészületek
    <ul>
      <li>Készíts egy könyvtárat ahová az össze fájl kerül.
      <li>Készítsd el a lemez képmását a <A HREF="dic.html"> DIC </A>
segítségével ebbe a könyvtárba.
      <li>Készíts egy <a href="opt.html#optwb">#?.info</a> fájlt "WHDLoad"
          &lt;alapértelmezett programmal&gt; és a "SLAVE=#?" paraméterrel, ami
a slave nevét tartalmazza. (vagy egyszerûen másold át az ikont a Példa
Installból, és kapcsold ki az összes paramétert a "SLAVE=" kivételével).
    </ul>
  <li>A Slave<br>
    A slave megírásához a következõ információkra van szükség:
    <ol>
      <li>Hol helyezkedik el a lemezen a fõ indító?
      <li>A fõ indítón belül hol van a lemezbetöltõ?
    </ol>
    Ezekhez az információkhoz elõször elemzeni kell az indítóblokkot.
    Legtöbbször a fõ indító innét töltõdik be exec.DoIO() segítségével.
    Néha egy speciális sávtöltõ van az indítóblokkban. Most megírhatjuk a
    Slave-et ami szimulálja az indítóblokkot és a betölti a fõ indítót a
    lemez képmásból. Most ki kell szednünk a fõ indítót a képmásból vagy a <a
    href="dump.html#memory">memória kiíratásból</a>. Ezután meg kell találnunk
    a betöltõt a fõprogramban. Ezt gyorsan úgy tehetjük meg, hogy megkeressük a
    <tt>$AAAAAAAA</tt> mintát (ezt az MFM dekódolás használja) egy
    hexa-szerkesztõvel. Ezután kivágjuk a megtalált területet (+/- <tt>$1000</tt>
    byte), visszaalakítjuk, és megkeressük a rutin elejét. Megértjük a
    paraméterlistát. Mostmár létrehozhatjuk azt a kódot, ami módosítja ezt a
    töltõrutint úgy, hogy minden hívás a Slave-hez megy. A Slave ezután
    módosítja a paramétereket és meghívja a <a href="../autodoc.html#resload_DiskLoad">resload_DiskLoad</a>.
    WHDLoad funkciót.
  <li>Ideális esetben az installálás kész.<br>
Az egyetlen hátralévõ dolog egy szép ikon készítése. Szedjél ki két képet a
WHDLoad <a href="snoop.html">kutató opciójával</a> és az <a href="sp.html">SP</a>
vagy a leállító vagy U.A.E. használatával és készítsd el az ikont. A 16 színû <a
href="ftp://ftp.wustl.edu/pub/aminet/pix/mwb/RomIcons10.lha">RomIcon</a> paletta
ajánlott.
</ol>
<h3>Lehetséges problémák és speciális esetek</h3>
<h4>Nem-standard sávtöltõ</h4>
Néhány program saját lemezformátumot használ. Ez azt jelenti hogy a <a
href="dic.html">DIC</a> nem tudja a lemezképmásokat létrehozni. Ilyen
lemezekrõl a <a href="rawdic.html">RawDIC</a> tud lemezképmásokat vagy fájlokat
létrehozni. További információkért lásd a RawDIC dokumentációját.
<h4>Több lemez</h4>
Ha a program egynél több lemezt használ, akkor a Slave-nek a
lemezhozzáféréseket át kell irányítania a képmás fájlba. Ez néha nem könnyû.
Néhány program támogat egynél több meghajtót, így használhatod a meghajtó
számát a lemez kiválasztásához. A legtöbb program egy azonosítót használ minden
lemezen a megkülönbönztetés miatt. Ebben az esetben változókat kell használni,
amelyek a lemez számát tartalmazzák, és minden lemezazonosító-hozzáférésnél
(ezt a lemez-töltõ paramétreinek elemzésébõl tudhatjuk meg) növelni kell a
változót (ha elérte az utolsó lemezt, akkor csökkenteni). Így remélhetõleg a
betöltõ beolvassa az azonosítót újra és újra addig amíg a megfelelõ lemezt meg
nem találja. Ezt persze a programba épített lemez-kérdezõ kikapcsolhatja.
<h4>Eredménytábla mentése</h4>
Nincs itt sok mondanivaló. Használd a <a href="../autodoc.html#resload_SaveFile">resload_SaveFile</a>
opciót egy bizonyos memóriaterület lemezre írásához. Ha akarod, ezt be is
kódolhatod, hogy a lamerek ne tudják könnyen módosítani. Nem javasolt közvetlen
lemezképmásba írás (a <a href="../autodoc.html#resload_SaveFileOffset">resload_SaveFileOffset</a>
opciót használva), mert ha valami balul sül el (pl. összeomlás), a képmások
valószínûleg megsérülnek.
<h4>Játékmentések</h4>
A mentések kezelése hasonló az eredménytábláéhoz.
<h4>Operációs rendszer használata</h4>
Amikor a slave és az instalált program elindul, a rendszer nem létezik, nem
érhetõ el, és nincs értelme elérni! Ezért az installált program mindenféle
elérését le kell tiltani. Ha nincs belõlük sok és nem számítanak a WHDLoad
környezetben  (mint pl. exec.Disable() vagy exec.SuperState()) egyszerûen NOP (<tt>$4e71</tt>)
kell. Ha fontos funkciókhoz érnek hozzá (mint exec.DoIO()), át kell irányítani
õket a Slave-hez és emulálni kell. Ha nagyon sok van belõlük, készíteni kell
egy egyszerû exec.library-t egy nemhasznált memória-területen (inicializálni
kell a longword-ot a <tt>$4</tt> címen). Megnézheted az Oscar.slave
forráskódját, amely exec.AllocMem() utasítást emulál. A rendszerhozzáférések
felismeréséhez a kezdeti execbase címe a következõ legyen: <tt>$f0000001</tt>,
de így minden olyan rutin, amely használja ezt, "Address Error" kivétet fog
generálni.<br>
Ha nagyon sok rendszerfunkció van használatban, használd a KickEmu csomagok
egyikét, amelyet a fejlesztõi csomagban találhatsz meg. Van egy a Kick 1.3
részére ('src/sources/whdload/kick13.s') és van egy a Kick 3.1 részére ('src/sources/whdload/kick31.s').
A csomagokhoz szükséges az eredeti Kickstart képmás és egy teljes
rendszer-környezetet fognak létrehozni a WHDLoad területén belül. További
információért nézd meg a mellékelt dokumentációt.
<h3>Gyakori kompatibilitási problémák</h3>
<h4>68000/68010/68ec020 korlátozott címterülete</h4>
Ezeken a processzorokon a címterület korlátozva van 16 MB-ra (<tt>$000000...$ffffff</tt>)
mert a processzoroknak csak 24 címvezetékük van. Emiatt az összes magasab címû
elérés az alsó 16 MB-ban lesz végrehajtva a 8 legnagyobb bit figyelmenkívül
hagyásával. Néhány program ezeket adattárolásra használja, vagy egyszerûen nem
törli. Az olyan processzorokon, ahol a teljes 4 GB-os címterület megvan (pl.
68020/680ec30/68030/68040/68060) ez nem mûködik, mivel a teljes 32-bites cím
lesz használva.<br>
A megoldás a hozzáférések módosítása és átirányítása a megfelelõ címre.<br>
Néha a különös címekhez való hozzáférés oka lehet egy nem inicializált mutató.
Ebben az esetben segíthet a <tt>$400</tt> - <a href="../autodoc.html#ws_BaseMemSize">ws_BaseMemSize</a> törlése.
<h4>Processzorok különbözõ stackframe-je</h4>
A megszakítások és kivétek során a processzorok által létrehozott stackframe-ek
különbözõek a 68k család tagjainál. A 68000-en a stackframe 6 byte, kivéve a
busz és címhibák. A stackframe a mentett SR-t (a7) és PC-t (2,a7) tartalmazza.
Minden más processzoron (68010+) a minimális stackframe 8 byte és tartalmazza a
vektor számát word-ként (6,a7). Ez a négy-word stackframe formátum <tt>$0</tt>
lesz létrehozva a "Trap #xx" és a megszakítások számára 68010-68060
processzorokon. A stackframe-ek más kivéteknél különböznek minden processzoron.
Az RTE utasítások különbözõek a 680000en és 68010+-eken. 68000-on csak
visszaállitja az SR-t és PC-t és folytatja a program végrehajtását a
megszakított címen. 68010+-okon kiüríti a stackframe-et a stackframe
formátumától függõen. <br>
Néhány program berak egy címet (PC) és egy SR-t és ezután végrehajt egy RTE
utasítást. Ez csak a 68000-en mûködik, 68010+-okon elõre nem látható eredményei
lesznek.
<br>Ha egy program ezt teszi, ki kell javítanod. Néha elég az RTE-t kicserélni
RTR-re.
<h4>MOVEM.x RL,-(An) 68000/010 és 68020/030/040 processzorokon</h4>
Különbség van, ha a regisztert predecrement módban (RL) használják, ekkor
tartalmazni fogja a regiszterlistát is. A 68020, 68030 és 68040 processzorokon
a memóriába írt érték a regiszter kezdeti értéke a mûvelet méretével csökkentve.
A 68000 és 68010 a kezdeti regiszter értéket írja (nincs csökkentés). <br>
Mivel egy ilyen konstrukció nem túl hasznos, jelenleg nincs egy program sem,
amelynek ez gondot okozna.
<h3>Általános útmutató installálók írásához</h3>
<ul>
<li>Ne módosítsd a nagyobbb processzorban lévõ regisztereket mint pl. VBR vagy CACR.
A VBR mindig 0 a Slave programozó szemszögébõl, mégha az automatikus vektorok
miatt (és Trap-ek miatt is, ha a <a href="../autodoc.html#WHDL_EmulTrap">WHDL_EmulTrap</a>
jelzõ be van állítva) mozgatva van. A CACR bitjei különböznek minden
processzoron. Csak egy használható módja van a <a href="cache.html">cache</a>
módosításához, használd a <a href="../autodoc.html">resload_SetCACR/SetCPU</a>
funkciót és a bitdef-eket az 'exec/execbase.i' és 'whdload.i' fájlokból.
Emellett az installálandó programban lévõ összes olyan dolgot, amely ezeket a
regisztereket módosítja, ki kell kapcsolni vagy át kell lépni, egyébként a WHDLoad
nem tud rendesen mûködni!
<li>Soha ne módosítsd a lemezképmásokat. Megvan az elõnye annak, ha valaki
lemezrõl akarja ezeket indítani, csak egyszerûen visszaírja õket lemezre (abban
az esetben, hogyha a program fut nagy javítások nélkül, ami nem túl gyakori).
<li> Ne használj fel közvetlenül a programból dolgokat a slave-ben (copyright probléma).
<li>Csak akkor engedélyezd a gyorsítótárakat ha az minden processzoron mûködik.
<li>Használj olyan kevés memóriát, maennyit csak lehetséges a <a href="../autodoc.html#ws_BaseMemSize">ws_BaseMemSize</a>
számára. Néhány embernek rezidens moduljai vannak a Chip memória végén, így
használd inkább a <tt>$1f0000</tt> címet a <tt>$200000</tt> helyett és a WHDLoad
tud abszolút lefoglalt memóriát használni.
</ul>
<h3>Tippek és trükkök</h3>
<h4>Mi a jobb, lemezképmások vagy fájlok használata?</h4>
Elõfordul, hogy lehetõséged van választani lemezképmások vagy valódi fájlok
között. Mindkettõnek megvan az elõnye. A lemezképmások általában könnyebben kezelhetõek
és gyorsabban létrehozhatóak a Slave által. De a valódi fájlok könnyebben
gyorsítótárazhatóak (ha csak kevés memória van vagy az nagyon töredezett). A
merevlemezen is kevesebb helyet foglalnak el a valódi fájlok, mint a
lemezképmások. Csak akkor használj lemezképmást ha sok fájl van (több mint 30).
</BODY>
</HTML>
