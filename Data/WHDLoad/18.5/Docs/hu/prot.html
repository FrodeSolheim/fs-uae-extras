<HTML>
<HEAD>
<TITLE>resload_Protect#? használata</TITLE>
<meta name="DC.Language" content="hu">
<meta http-equiv="content-language" content="hu">
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2">
<!-- $Id: prot.html 1.5 2009/02/05 20:38:15 wepl Exp wepl $ -->
</HEAD>
<BODY>
<h3>resload_Protect#? használata</h3>
<h4>Elmélet</h4>
Vannak olyan helyzetek, amikor hasznos lehet tudni azt, hogy az installált
program milyen memória-hozzáféréseket hajt végre.
A <a href="../autodoc.html">resload_Protect#?</a> funkciókkal
lehetséges bizonyos memóriahelyek védelme olvasás és/vagy írás ellen.
A védelem azt jelenti hogy minden ilyen védett területhez való hozzáférés
Access Fault kivétet fog létrehozni, amit a WHDLoad egy kérdezõvel fog
megjeleníteni. Ha egy memóriarészt védettnek állítasz be a
<a href="../autodoc.html">resload_Protect#?</a> funkcióval, a
WHDLoad módosítani fogja a lapleírókat az MMU fordítási fában.
Ezentúl minden védett laphoz való hozzáféréskor a CPU Access Fault kivétet fog
generálni. A kivét handler a WHDLoad-on belül elenõrzi a kivét okát.
Ha az ok egy hozzáférés volt egy védett <a href="mmu.html">laphoz</a> de a
hozzáférés nem egyezik a védett területtel, akkor a hozzáférés emulálva lesz,
és normál programfuttatás folytatódik. Egyébként a WHDLoad kilép a megfelelõ
kérdezõvel. Ha a hozzáférés egy hozzáférés az utasításokhoz (pl. a cpu
megpróbál egy kódot betölteni), az mindig emulálva lesz, vagy más szavakkal a <a
href="../autodoc.html">resload_Protect#?</a> funkciók csak az adatok
olvasását és írását szabályozzák. Tény hogy minden védett laphoz való
hozzáférés (jelenlegi lapméret $1000) hozzáférési kivétet fog létrehozni, még
ha a védett terület csak egy byte, az eredmény a program nagymértékû
belassulása lesz. Különösen ha a kód ugyanazon a lapon van. Ha program függ a
végrehajtási sebességtõl, a futásban problémák adódhatnak. Ezért elõfordulhat,
hogy néhány program nem mûködik a védelmi funkcióval.
<h4>Példa: kódok ellenõrzése</h4>
Ha egy játékot installálsz a WHDLoad segítségével, módosítanod kell az eredeti
betöltõ rutint úgy, hogy a WHDLoad töltse be a játék adatait. Néhány játék
ellenõrzi a kódterületeket, hogy nem módosították-e az eredeti kódot.
Ezeket az érzékelõ rutinokat néha nehéz megtalálni. De a <a
href="../autodoc.html">resload_Protect#?</a> funkciók használatával
ez könnyû. Csak annyit kell tenned, hogy levéded olvasástól azokat a
területeket, amelyeket megváltoztattál. Ezután minden rutin amely megpróbálja
ellenõrizni és beolvasni a megváltoztatott kódot, egy hozzáférési hibát fog
generálni. És így megtudod, hogy hol van a rutin.
<h4>Korlátozások</h4>
Nem védheted le azt a területet amelyre az SSP mutat. Ha ezt teszed,
és egy kivét történik, az egy Double Bus Fault-ot eredményez, mivel a CPU
nem tudja kiírni a kivét stackframe-et. A Double Bus Fault után csak egy reset
után lehet folytatni a végrehajtást. A WHDLoad ellenõrzi a védett terület és az
SSP konfliktusát, és megszûnteti azt, de ez nem segít, ha az SSP késõbb
megváltozik.
<ul>
<li>68020 + 68851
<ul>
<li>ez a hardver jelenleg nem támogatott
</ul>
<li>68030
<ul>
<li>3-byte átvitelek nem támogatottak és valódi hozzáférési kivétet hoznak
létre, ilyen átvitelek történhetnek, ha egy longword hozzáférés történik egy páratlan címen a
laphatárnál (pl. "<code>tst.l ($fff)</code>" ahol a $1000 lap védett),
mivel ez érvénytelen 68000-en, ezért valószínûleg ilyet sose fogsz látni
<li>zárt átvitelek <code>tas</code>, <code>cas</code> vagy <code>cas2</code>
kód miatt nem támogatottak és valódi hozzáférési kivétet hoznak létre, ez nem
gond, mert a zárt átvitelt nem támogatja az Amiga hardvere
</ul>
<li>68040
<ul>
<li>ez a hardver jelenleg nem támogatott
</ul>
<li>68060
<ul>
<li>félrecímzett adatfolyamok hozzáférés nem támogatott és valódi hozzáférési kivétet hoznak
létre, a félrecímzett hozzáférés egy olyan hozzáférés, amely két lapon nyúlik
át (és ezek közül legalább az egyik vagy mindkettõ védett), például "<code>tst.l ($ffe)</code>"
a $0..$fff lapot és a $1000..$1fff lapot is módosítja, ez a korlát valódi
probléma és a resload_Protect funkciót majdnem használhatatlanná teszi,
valószínûleg késõbb megpróbálom támogatni, de ez nehéz
<li>félrecímzett adatfolyamok hozzáférés nem támogatott és valódi hozzáférési kivétet hoznak
létre, és ha mindkét érintett lap védett, ezt az együttállást el kell kerülni
az esetek nagy részében
<li>zárt átvitelek <code>tas</code>, <code>cas</code> vagy <code>cas2</code>
kód miatt nem támogatottak és valódi hozzáférési kivétet hoznak létre, ez nem
gond, mert a zárt átvitelt nem támogatja az Amiga hardvere
<li>a védett lapon lévõ utasítások (és emiatt emuláltak) és az
állapotregiszter supervisor részéhez való hozzáférések hibásan lesznek
végrehajtva, ezek az utasítások mindig 1-re állítják a nyomkövetõ bitet és a
megszakítás prioritás maszkját 7-esre, a supervisor rész bármilyen módosítása
hatástalan lesz (pl. a supervisor rész változatlan marad)
<li><code>movem</code> utasítás hozzáférhet egy védett területhez anélkül, hogy hozzáférési
hiba kivétet hozna létre, ez azért lehetséges, mert csak az elsõ hozzáférés lesz
ellenõrizve (word vagy longword)
<li><code>move16</code> és a dupla pontosságú mûveletek (FPU) nem támogatottak
és valódi hozzáférési kivétet hoznak létre
<li>a "<code>move (mem),(mem)</code>" utasítás a átlapoló forrás és
célcímzéssel hozzáférési kivétet hoznak létre, mivel a félrecímzés helytelenül
lesz végrehajtva, például a "<code>move.l ($ffc),($ffe)</code>" utasítás, ahol
a $1000..$1fff lap védett és a memória végrahajtás elõtti tartalma: ($ffc)=$11112222, ($1000)=$33334444,
végrehajtás után a $1000 tartalma: $11114444 és nem $22224444
</ul>
</ul>
</BODY>
</HTML>
