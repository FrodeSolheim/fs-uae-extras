<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1250">
	<TITLE>Rendszerfigyel&otilde;k / Leállító</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 2.0  (Win32)">
	<META NAME="CREATED" CONTENT="20061104;22522514">
	<META NAME="CHANGEDBY" CONTENT="Márton Dósa">
	<META NAME="CHANGED" CONTENT="20061104;23001590">
	<META NAME="DC.Language" CONTENT="hu">
	<META HTTP-EQUIV="content-language" CONTENT="hu">
	<!-- $Id: freezer.html 1.4 2011/09/04 23:01:44 wepl Exp wepl $ -->
</HEAD>
<BODY LANG="hu-HU" DIR="LTR">
<H3>Rendszerfigyelõk / Leállító</H3>
<P>Nagyon sok rendszerfigyelõ program létezik. Az ilyen programok
használata nagy segítség lehet a fejlesztés alatt és a Slave-ek
hibakeresése közben. A WHDLoad közvetlenül támogatja a HRTMon és a
ThrillKill programokat. Mások is használhatóak a <A HREF="opt.html#NoTrapHandler">NoTrapHandler/S</A>
opcióval (ennek természetesen vannak hátrányai). Ha szeretnél egy
másik számára közvetlen támogatást, vedd fel velem a kapcsolatot és
ha meg lehet csinálni, belerakom a támogatást. A WHDLoad indításakor
ellenõrzi, hogy van-e aktív támogatott figyelõ. Ha van, akkor a
WHDLoad csinál néhány extra dolgot. Ha az MMU-t használja a WHDLoad,
akkor az megadja, hogy az a memória, amit a figyelõ használ, érvényes
és WriteThrough gyorsítótárazható. A játék/demó futtatása alatt
minden NMI megszakítás az NMI vektorban a figyelõ vektortáblájába
lesz mentve. Emellett ha a VBR a WHDLoad által lett elmozgatva
(<A HREF="opt.html#NoVBRMove">NoVBRMove/S</A> nincs beállítva és a
CPU legalább 68010), összehasonlítja a <A HREF="opt.html#FreezeKey">FreezeKey</A>
értékét a jelenlegi billentyûzet értékével minden megszakítás alatt.
Ha az értékek egyeznek, a WHDLoad megcsinálja a szükséges
billentyûzet dolgokat, átalakítja a stackframe-et NMI stackframe-é és
belép a figyelõbe ezen az NMI kezelõn keresztül.
</P>
<H4>HRTMon</H4>
<P>A memória érzékelése relatíve biztonságos. Úgy gondolom, hogy ez
így lesz a következõ verziókban is. Vigyázz, ha az MMU-t használja a
WHDLoad: ne lépj ki a BaseMem-en kívüli területre. Össze fog omlani,
mivel a HrtMon nem kezeli a fellépõ Access Fault Exception-t.</P>
<P>A HRTmonPrefs-ben be kell kapcsolni a 'No VBR move' kapcsolót,
egyébként nem tudsz majd belépni a monitorba, mialatt a WHDLoad fut.</P>
<P>Miután visszatérsz az elindított HRTmon programból, a WHDLoad
alatt futó program grafikus képernyõjén hibák jelenhetnek meg. Ez
azért van, mert a HRTmon felülír néhány egyedi regisztert. Ezt úgy
kerülheted el, hogy megadod a HRTmon számára a helyes értéket, pl. <TT>'e
$100 $5200'</TT> egy 32 színû képernyõ esetén, mielõtt kilépsz
belõle.</P>
<P>A WinUAE be&eacute;p&iacute;tett HRTMon programja csak akkor ismerhetõ fel, ha m&aacute;r elõzõleg el lett ind&iacute;tva legal&aacute;bb egyszer (PgUp billentyûvel). Az elsõ aktiv&aacute;l&aacute;s &aacute;ll&iacute;tja be az NMI vektort, amelynek a seg&iacute;ts&eacute;g&eacute;vel a WHDLoad megtal&aacute;lja a monitor-programot.</P>
<H4>ThrillKill</H4>
<P>Nincsen használható azonosító a leállítóban, ezért egy
kódösszehasonlítás van használva. Ezért az érzékelés nem mûködik más
verziókkal.
</P>
</BODY>
</HTML>