<html>
<head>
  <title>CPU Cache Handling</title>
  <meta name="DC.Language" content="ru">
  <meta http-equiv="content-language" content="ru">
  <meta http-equiv="content-type"
 content="text/html; charset=windows-1251">
<!-- $Id: cache.html 1.9 2014/12/04 23:37:38 wepl Exp wepl $ -->
</head>
<body>
<h3>Обзор кэша центрального процессора</h3>
<p>Для увеличения скорости некоторые процессоры
(CPU) семейства 68k имеют возможность при доступе к
памяти использовать кэш.<br>
Кэши всегда используют логическую адресацию,
включая функциональный код доступа. Это
означает, что доступ в режиме пользователя (User Mode)
и режиме супервайзера) Supervisor Mode будут создавать
различные входные данные кэша (за дополнительной
информацией обращайтесь к документации по
процессорам фирмы Motorola). </p>
<p>вот краткий обзор особенностей кэшей
процессоров семейства <strong>68k</strong>:
</p>
<ul>
  <li>68000 - отсутствует </li>
  <li>68010
    <ul>
      <li>Команда предварительной выборки <br>
два слова предварительной выборки, одно слово декодирующего регистра </li>
      <li>Режим Цикла <br>
используется если за одним словом команды следует DBcc зацикленный на предыдущую команду, и до окончания цикла больше нет никаких команд</li>
    </ul>
  </li>
  <li>68020
    <ul>
      <li>Команда предварительной выборки <br>
длинное слово </li>
      <li>Кэш команд <br>
16 линий по 16 байт = 256 байт <br>
может быть активзирован или остановлен через CARC </li>
    </ul>
  </li>
  <li>68030
    <ul>
      <li>Команда предварительной выборки <br>
длинное слово </li>
      <li>Кэш команд <br>
16 линий по 16 байт = 256 байт <br>
может быть активизирован или остановлен через CARC
<br>Burst режим заставляет считывать все линии кэша за раз, если это поддерживается аппаратно
<li>Кэш данных <br>
16 линий по 16 байт = 256 байт <br>
может быть активизирован или остановлен через CARC <br>
всегда со сквозной записью (WriteThrough)<br>
выбор режима кэширования данных при записи (Write Allocation) запрещает осуществлять запись другим пользователям/супервайзерам
<br>Burst режим заставляет считывать все линии кэша за раз, если это поддерживается аппаратно
</li>
  <li>68040
    <ul>
      <li>Команда предварительной выборки <br>
длинное слово </li>
      <li>Кэш команд <br>
256 линий по 16 байт = 4096 байт <br>
может быть активизирован через CARC </li>
      <li>Кэш данных <br>
256 линий по 16 байт = 4096 байт <br>
может быть активизирован через CARC <br>
возможность выбора режима CopyBack/WriteThrough через MMU </li>
    </ul>
  </li>
  <li>68060
    <ul>
      <li>Команда предварительной выборки <br>
длинное слово </li>
      <li>Кэш команд <br>
512 линий по 16 байт = 8192 байт <br>
может быть активизирован, остановлен и уменьшен в 2 раза через CARC </li>
      <li>Кэш ветвления (Branch Cache)<br>
может быть активизирован через CARC <br>
не изменяется установками MMU! </li>
      <li>Суперскалярная обработка (Superscalar Dispatch)<br>
может быть активизирован через CARC </li>
      <li>Кэш данных <br>
512 линий по 16 байт = 8192 байт <br>
может быть активизирован, остановлен и уменьшен в 2 раза через CARC<br>
возможность выбора режима CopyBack/WriteThrough через MMU </li>
      <li>Push Buffer <br>
может быть отключен через PCR </li>
      <li>Store Buffer <br>
может быть активизирован через CARC <br>
Страницы <strong>не</strong> должны быть некэшируемыми (NonCachable
Serialized (precise)) </li>
    </ul>
  </li>
</ul>
<h4><a name="cache">Работа с кэшем в WHDLoad</a></h4>
<p>Первая важная вещь состоит в понимании того,
что кэш процессоров 68030..68060 управляется с помощью
Регистра Контроля Кэша (<strong>CACR</strong>) и MMU<br>
С помощью CACR кэш может бать включен или выключен.
Используя одну страницу памяти MMU (4 кб с WHDLoad)
можно обозначить каким образом будет
производиться кэширование. <br>
На процессорах 68030 страница памяти может быть
кэшируемой (Cacheable) или некэшируемой (NotCacheable). На
процессорах 68040/68060&nbsp; - кэшируемой WriteThrough
(сквозное), CopyBack, некэшируемой NonCachable (неточно)&nbsp;
или некэшируемой NonCachable Serialized (точно). </p>
<p>Если WHDLoad не использует MMU, то управление
возможно только с помощью CACR. </p>
<h4>Стандартные установки кэша</h4>
<p>По умолчанию области WHDLoad, Slave и ExpMem помечены как
кэшируемые CopyBack. Область BaseMem помечена как NonCachable,
а кэш данных&nbsp; и кэш команд включены через CACR.
Таким образом, если программа располагается в
области BaseMem, то она запускается с отключенным
кэшем, но WHDLoad, Slave и ExpMem используют кэш для максимального быстродействия.
Если MMU не используется WHDLoad, в результате этих настроек, оба кэша отключаются
т.к. без MMU нельзя сделать отличающиеся настройки для разных участков памяти
и, следовательно, если любой диапазон помечен как NonCacheable (некешируемый), отключаются все кэши.
</p>
<h4>Управление кэшем (для программистов)</h4>
<p>Имеется две функции в WHDLoad для управления
кэшами: <a href="../autodoc.html#resload_SetCACR">resload_SetCACR</a> и <a
 href="../autodoc.html#resload_SetCPU">resload_SetCPU</a>. <strong>Resload_SetCACR</strong>
довольно старая функция и она может быть
полностью заменена с помощью r<strong>esload_SetCPU</strong>
(WHDLoad сам обрабатывает аргументы функции <strong><a href="../autodoc.html#resload_SetCACR">resload_SetCACR</a></strong>
и автоматически вызывает функцию <strong><a href="../autodoc.html#resload_SetCPU">resload_SetCPU</a></strong>).
В любом случае рекомендуется использовать
функцию <strong><a href="../autodoc.html#resload_SetCACR">resload_SetCACR</a></strong> всем, кто плохо знаком
с тем, как работать с кэшами и каково их влияния
на систему Амиги. Использование функции <strong><a href="../autodoc.html#resload_SetCACR">resload_SetCACR</a></strong>
и кэш данных,&nbsp; можно включать и отключать
независимо друг от друга. <strong>Resload_SetCACR</strong>
влияет только на кэширование области основной
памяти (BaseMem).</p>
<h4>Управление кэшем (для пользователей)</h4>
<p>Если программист ответственно подошел к своей
работе, то пользователю вообще не нужно ломать
голову относительно установок кэша, поскольку
все настройки кэша будут выполнены Slave-модулем
самостоятельно. <br>
Однако, может быть две причины для изменения
установок кэша вручную. Первая - это проблемы с
установленной программой, из-за того что она
работает слишком быстро (например, происходит
порча графики), а вторая , чтобы ускорить работу
установленной программы. </p>
<p>Чтобы заставить работать программы, которые
приводят к ошибке&nbsp; из-за использования кэша,
нужно активизировать опцию <a href="opt.html#NoCache">NoCache</a>.
Эта опция выключает все кэши и помечает всю
память как некэшируемую NonCachable Serialized (точно). Если
компьютер имеет 32-битную Chip-память то он по
прежнему будет работать быстрее чем A500. </p>
<p>Для того чтобы ускорить работу установленной
программы, могут быть выставлены некоторые опции
для активации кэша. Эти опции будут
перезаписывать внутренние установки Slave-модуля.
С процессорами 68020 может быть установлена опция <a
 href="opt.html#Cache">Cache</a> . С процессорами 68030 еще может
быть использована и опция <a href="opt.html#DCache">DCache</a>,
которая также включает в себя опцию управления
кэшем. Для использования с процессорами 68060
существует еще несколько опций управления
кэшами: <a href="opt.html#BranchCache">BranchCache</a>, <a
 href="opt.html#StoreBuffer">StoreBuffer</a> и <a
 href="opt.html#SuperScalar">SuperScalar</a>.
Опция <a href="opt.html#ChipNoCache">ChipNoCache/S</a> может увеличить
производительность на процессорах 68040 и 68060 (см.
ниже). <a name="chipmem"></a></p>
<h4>Кэширование чип-памяти (Chip-Memory)</h4>
<p>Кэширование может производиться не только
средствами самого процессора (CACR) и MMU, а так же и
внешними аппаратными средствами. Процессор по
шине передаёт сигнал в случае, если он пытается
кэшировать доступ. И внешние аппаратные средства
могут сигнализировать процессору (после того как
адрес был выставлен на шине адреса во время
доступа к памяти), что доступ не должен
кэшироваться. <br>
На сколько мне известно, на всех Амигах и внешних
акселераторах, содержащих процессор не ниже 68030
(т.к. они имеют кэш данных), аппаратные средства
сообщают процессору, что память не кэшируется
или не используется. Воздействие происходит на
всю Chip-память и область IO (Cia/Custom/RTC) которые не
должны кэшироваться кэшем данных. Это необходимо
для того, чтобы избежать конфликтов, например,
из-за работы DMA. <br>
Реакция процессора на аппаратный отказ
кэширования доступа может отличаться на разных
типах процессоров. На 68030 нет никакого влияния на
скорость доступа, данные просто не будут
кэшироваться. На 68040 доступ на чтение будет
выполняться с максимальной скоростью, но доступ
на запись (CopyBack) будет отменен и начат сначала без
кэширования, что приводит к тому, что доступ
будет примерно в 5 раз (зависит от аппаратных
средств и скорости процессора) медленнее по
сравнению с некэшируемым доступом. На 68060 доступ
как на чтение, так и на запись будет отменен и
перезапущен. Доступ на чтение будет примерно в 3
раза медленнее, а доступ на запись медленнее
примерно в 5 раз. <br>
Упомянутые выше проблемы связаны с доступом к
данным. Доступ к командам обычно не вызывает
проблем и также кэшируется в Chip-памяти. Но
существуют некоторые аппаратные средства
(возможно, просто неисправные), которые не
позволяют кэширование команд в Chip-памяти. На
таких системах должна использоваться опция <a
 href="opt.html#ChipNoCache">ChipNoCache/S</a>, чтобы избежать
значительного замедления в работе установленной
программы, поскольку иначе (без использования
этой опции) доступ к инструкциям будет примерно в
2 раза медленнее.</p>
<p>Это поведение может быть проверено путем запуска модуля <i>Speed.Slave</i>,
находящегося в директории <tt>src/memory-speed</tt> архива для разработчиков. </p>

<h4>Режим Burst (Burst Mode)</h4>
Режим Burst в 68030 заставляет ЦП, в случае отсутствия кэша,
всегда считывать линию кэшa целиком (16 bytes), вместо только запрошенного длинного слова.
Режим Burst должен поддерживаться аппаратно, если же нет, Burst не произойдет без временных потерь.
Режим Burst может быть активирован отдельно для команды и для кэша данных.
Так как доступ Burst требует больше времени, чем одиночный доступ, режим Burst дает прирост в скорости только
 если большинство данных в линии кэша также использовались ранее. 
Для кэша команд режим Burst обычно повышает производительность. 
Для кэша данных часто только в случае последовательного чтения памяти. 
Начиная с версии 18.0, WHDLoad включает Burst команд совместно с кэшем команд. 
Burst данных не будет включен программой WHDLoad.

<h4>Кэширования данных при записи (Write Allocation)</h4>
<p>Кэширование данных при записи управляет
работой кэша на процессорах 68030 когда при
операции записи происходит потеря кэша.
Кэширование данных при записи должно быть
активизировано, когда программа запущена в
режиме пользователя (User Mode). Если установленная
программа запускается только в режиме
супервайзера (Supervisor Mode), то Кэширование данных
при записи может быть отключено, что может дать
небольшой прирост скорости. </p>
<h4>Кэш ветвления (Branch Cache)</h4>
<p>Кэш ветвления доступен только на 68060. Это своего
рода кэш инструкций для команд перехода. Но в
отличие от кэша команд не зависит от установок MMU!
Это означает, что даже если страница памяти
помечается как не кэшируемая, команды перехода
все равно будут кэшироваться при условии, что кэш
ветвления активен.</p>
<hr>
<p>За дополнительной информацией обращайтесь к
справочнику по микропроцессорам Motorola. Если у вас
есть поправки или добавления которые хотелось бы
видеть на этой странице, пожалуйста напишите <a
 href="mailto:wepl@whdload.de">мне</a> . <br>
</p>
</body>
</html>
