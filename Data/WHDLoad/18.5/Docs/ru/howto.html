<html>

<head>
<title>Programming WHDLoad</title>
<meta name="DC.Language" content="ru">
<meta http-equiv="content-language" content="ru">
<meta http-equiv="content-type" content="text/html; charset=windows-1251">
<!-- $Id: howto.html 1.6 2014/12/04 23:37:38 wepl Exp wepl $ -->
</head>

<body>

<h3>Схематическое описание работы программы</h3>

<p>Следующая таблица показывает процесс
выполнения программы, когда запускается
программа, установленная с помощью WHDLoad. Я
надеюсь, что это поможет понять, как работает WHDLoad
и как WHDLoad, slave-модуль и установленная программа
взаимодействуют между собой. </p>

<p>&nbsp;</p>

<table cellpadding="3">
<tbody>
  <tr>
    <td valign="top">ПОЛЬЗОВАТЕЛЬ</td>
    <td><ul>
      <li>запускает демо или игру, щелкая на иконку или
        запуская WHDLoad через командную строку </li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top">Операционная Система</td>
    <td valign="top"><ul>
      <li>загружает WHDLoad и призводит запуск </li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top">WHDLoad</td>
    <td><ul>
      <li>проверяет програмную среду и аппаратные
        средства </li>
      <li>загружает и проверяет slave-модуль </li>
      <li>резервирует необходимое количество памяти для
        установленной программы </li>
      <li>если активизирована опция <a href="opt.html#Preload">Preload/S</a>,
        то в оперативную память загружются образы диска
        и файлы (насколько позволяет свободная память) </li>
      <li>отключает OS (отключает многозадачность и
        перерывания, переключает графику на режим OCS,
        инициализирует все аппаратные средства,
        используя заданные значения)</li>
      <li>осущесвствляет переход на выполнение slave-модуля</li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top">Slave-модуль</td>
    <td><ul>
      <li>загружает главный исполняемый файл
        установленной программы, вызывая функцию WHDLoad
        (например, <a href="../autodoc.html#resload_DiskLoad">resload_DiskLoad</a> или <a
        href="../autodoc.html#resload_LoadFile">resload_LoadFile</a>) </li>
      <li>исправляет исполняемый файл (чтобы программа
        загрузила свои данные через slave, устраняет
        проблемы несовместимости, активизирует функцию
        выхода из программы) </li>
      <li>запускает главный исполняемый файл</li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top">Установленная программа</td>
    <td><ul>
      <li>выполняется</li>
      <li>при подгрузке данных с диска, вызывает
        slave-модуль (потому что slave-модуль исправил
        исполняемый файл), slave-модуль вызывает WHDLoad, и WHDLoad
        частично активизирует OS чтобы загрузить данные
        (только если данные не были предварительно
        подгружены - см.&nbsp;<a href="opt.html#Preload">Preload</a>), затем
        возвращается в установленную программу и
        программа продолжает выполнение </li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top">ПОЛЬЗОВАТЕЛЬ</td>
    <td><ul>
      <li>выходит из программы, нажимая клавишу выхода <a
        href="opt.html#QuitKey">QuitKey</a></li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top">Slave-модуль</td>
    <td><ul>
      <li>возвращается в WHDLoad, вызывая <a href="../autodoc.html#resload_Abort">resload_Abort</a></li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top">WHDLoad</td>
    <td><ul>
      <li>перезапускает OS (восстанавливает состояние
        регистров, памяти, дисплея) </li>
      <li>освобождает все занятые ресурсы </li>
      <li>производит возврат в OS</li>
    </ul>
    </td>
  </tr>
</tbody>
</table>

<h3>Как устанавить диск использующий трековый загрузчик (trackloader)</h3>

<p>Это совсем краткое пошаговое описание того, как создать патч для NDOS игры/демо, использующий WHDLoad.
Данный пункт поясняет самый простой вариант. В реальности
такого варианта скорее всего не будет. В главах
же следующих за этой, будут отдельно описаны
особые случаи и проблемы, с которыми вы можете
столкнуться.

<ol>
  <li>Предварительная подготовка <ul>
      <li>Создайте папку, в которой будут находиться все
        файлы. </li>
      <li>Создайте в этой же папке образ диска, используя <a
        href="dic.html">DIC</a>.</li>
      <li>Создайте <a href="opt.html#optwb">*? .info</a> файл, в котором
        инструментом по умолчанию является &quot;<strong>WHDLoad</strong>&quot;
        &nbsp; и параметром (Tooltype) &quot;<strong>SLAVE=</strong>#?&quot;, где
        &quot;#?&quot; - имя slave-модуля (или просто скопируйте
        иконку из инсталяционного примера и отключите
        все параметры (Tooltypes) кроме &quot;SLAVE=&quot;).</li>
    </ul>
  </li>
  <li>Slave-модуль<br>
    Для создания slave-модуля нам необходима следующая
    информация:<br>
    &nbsp;&nbsp;&nbsp; 1) Где на диске расположен главный
    исполняемый файл?<br>
    &nbsp;&nbsp;&nbsp; 2) Где внутри главного исполняемого
    файла располагается загрузчик диска?<br>
    Чтобы получить эту информацию мы сначала
    анализируем загрузочный блок (bootblock). Как правило,
    главный исполняемый модуль загружается отсюда,
    используя функцию <strong>exec.DoIO().</strong> Иногда в
    загрузочном блоке присутствует загрузчик
    дорожки (trackloader). Теперь мы напишем Slave-модуль,
    который будет эмулировать загрузочный блок и загружать главный исполняемый модуль из образа диска.
	Сейчас нам необходимо вытащить главный исполняемый модуль из образа диска или из 
	<a href="dump.html#memory">дампа памяти</a>.
	После этого нам нужно найти загрузчик в главном исполняемом файле. Самый быстрый путь состоит в том, чтобы
    попробовать найти в HEX-редакторе последовательность <tt>$AAAAAAAA</tt> (используется MFM-декодированием). 
	Вырежте найденную область с захватом +/- $1000 байт, дизассемблируйте, и ищите начало процедуры. 
	Когда загрузчик будет найден, разберитесь какие параметры загрузки он
    использует(адрес загрузки, длина). Теперь мы
    создаем код для slave-модуля, который исправит эту
    процедуру загрузчика, и который будет
    обрабатывать все запросы переадресовывая их
    slave-модулю. Slave-модуль будет корректировать
    параметры загрузки и вызывать функцию WHDLoad'а <a
    href="../autodoc.html#resload_DiskLoad">resload_DiskLoad</a>.</li>
  <li>В случае такого идеального варианта, slave-модуль уже готов.<br>

    Теперь осталось единственное - создать хорошую иконку. Сграбьте две картинки, используя опцию <a
    href="snoop.html">Snoop</a> программы WHDLoad и <a href="sp.html">SP</a> или
    системный монитор или UAE для извлечения картинки и создания иконки.
    Рекомендуется использовать 16 цветную <a href="ftp://ftp.wustl.edu/pub/aminet/pix/mwb/RomIcons10.lha">RomIcon</a> палитру.</li>
</ol>

<h3>Возможные проблемы и особые случаи</h3>

<h4>Нестандартный загрузчик дорожки</h4>

<p>Некоторые программы используют свой
собственный формат диска. Это означает, что <a
href="dic.html">DIC</a> не в состоянии создать образ такого
диска. Чтобы прочитать файлы с такого диска или
создать его образ, рекомендуется использовать <a
href="rawdic.html">RawDIC</a>. За подробностями обращайтесь к
документации программы <strong>RawDIC</strong>. </p>

<h4>Программа использует несколько дисков</h4>

<p>Если программа использует больше чем один диск,
то slave-модуль должен переадресовать доступы к
дискам к соответствующему файлу образа. Иногда
это не легко. Некоторые программы поддерживают
более одного дисковода, так что вы можете
использовать номер дисковода для выбора нужного
диска. Большинство программ использует
идентификатор (например название) на каждом
диске, чтобы различать их. В этом случае,
используйте переменную, которая содержит номер
диска, и при каждом обращении к идентификатору
диска (определяйте такой доступ, анализируя
параметры для загрузчика диска) и увеличивайте
переменную (а если достигнут последний диск, то
уменьшайте её), в надежде на то, что загрузчик
будет перечитывать идентификаторы снова и снова
пока не обнаружит нужный диск. Некоторые
программы выдают запрос, чтобы пользователь
вставил правильный диск - оключите этот запрос. </p>

<h4>Сохранение таблицы рекордов (Highscore)</h4>

<p>Ну, что тут сказать. Используйте функцию <a
href="../autodoc.html#resload_SaveFile">resload_SaveFile</a>, чтобы записать
соответствующую область памяти на диск. Если
хотите, то можете еще и зашифровать ее так, чтобы
&quot;чайникам&quot; было не легко её исправить. Не
рекомендуется производить запись
непосредственно в образ диска (используя функцию
<a href="../autodoc.html#resload_SaveFileOffset">resload_SaveFileOffset</a>) потому, что
если что-то пойдет не так, как надо (например,
какая-нибудь ошибка или зависание), то возможно,
что образ диска будет поврежден. </p>

<h4>Сохранение прогресса игры (Savegames)</h4>

<p>Запись прогресса игры осуществляется теми же
способами, что и в случае с таблице рекордов.</p>

<h4>Доступы к операционной системе</h4>

<p>Во время работы slave-модуль и установленная
программа не должны иметь никаких обращений к OS!
Поэтому все обращения из установленной
программы должны быть отключены или
перенаправлены. Если их не так много и они не
нужны при работе через WHDLoad (типа <strong>exec.Disable()</strong>
или <strong>exec.SuperState()</strong>), то просто замените их
командой <strong>NOP</strong> (<strong><tt>$4e71</tt></strong>). Если
вызовы несут важную функцию (типа <strong>exec.DoIO()</strong>),
переадресуйте их slave-модулю, и эмулируйте их.
Также можете создать простую exec.library в
неиспользованной области памяти
(проинициализируйте длинное слово по адресу <strong><tt>$4</tt></strong>).
Посмотрите как это сделано в исходном тексте для
модуля &quot;Oscar.slave&quot;, который эмулирует <strong>exec.AllocMem()</strong>.
Для обнаружения таких вызовов OS, выставьте
начальный execbase в <strong><tt>$f0000001</tt></strong> с той целью,
чтобы все программы, которые любят использовать
execbase, выдали &quot;Ошибку Адреса&quot;.<br>
Если эмулировать функции OS слишком сложно, тогда
просто используйте один из kickemu-пакетов, которые
могут быть найдены в дистрибутиве whdload-dev. Там
есть один пакет для Kick 1.3 ('src/sources/whdload/kick13.s'') и один
для Kick 3.1 ('src/sources/whdload/kick31.s''). Эти пакеты требуют
оригинального образа кикстарта и создают
полноценную OS в WHDLoad. См. также файлы readme, которые
поставляются в комплекте с этими пакетами.</p>

<h3>Проблемы совместимости</h3>

<h4>Ограниченное адресное пространство на
68000/68010/68ec020</h4>

<p>На этих процессорах адресное пространство
ограничено размером 16 Мб (<tt>$000000... $ffffff</tt>), потому
что центральный процессор имеет только 24
адресных линии. В результате все доступы к более
высоким адресам выполняются к адресам ниже 16 Мб,
просто игнорируя старшие 8 бит адреса. Некоторые
программы используют эти биты, для хранения
данных, или просто забывают очищать их. На
процессорах с полным 4Гб адресным пространством,
типа 68020/680ec30/68030/68040/68060 это происходить не будет,
потому что обращение будет идти к полному 32-х
битному адресу.<br>
Для решения этой проблемы, вы должны
подкорректировать эти вызовы и перенаправить их
на соответствующие адреса.<br>
Иногда причиной доступа к странным адресам может
быть непроинициализированный указатель. В этом
случае может помочь очистка <strong><tt>$400</tt></strong> - <strong><a href="../autodoc.html#ws_BaseMemSize">ws_BaseMemSize</a></strong>.
</p>

<h4>Различный стековый фрейм на разных процессорах</h4>

<p>Стековые фреймы, созданные процессором после
перерываний и событий, различны для разных
процессоров семейства 68К. На 68000 стековый фрейм
составляет 6 байт, за исключением &quot;Ошибки
Адреса&quot; и &quot;Ошибки Шины&quot;. В стековом фрейме
находится сохраненное значение SR в (a7) и PC в (2,a7).
На всех других процессорах (68010 +) минимальный
стековый фрейм составляет 8 байт и дополнительно
содержит номер вектора как слово в (6,a7). Этот
формат стекового фрейма $0, состоящий их четырёх
слов, создан для &quot;Trap #xx&quot; и прерываний на
68010-68060. Стековые фреймы для других событий
различны на каждом процессоре. Инструкция RTE на
68000 работает иначе чем на 68010+. На 68000 она просто
восстанавливает SR и PC и продолжает выполнение
программы с прерванного адреса. На 68010 + она
дополнительно освобождает стековый фрейм в
зависимости от его формата. <br>
Некоторые программы проталкивают (записывают в
стек?) адрес (PC) и SR, а затем выполняют инструкцию
RTE. Это работает только на процессорах 68000, а на
68010+ результат непредсказуем. <br>
Если программа работает таким образом, вы должны
исправить это место. Иногда бывает достаточно
заменить RTE на RTR. </p>

<h4>MOVEM.x RL,-(An) на 68000/010 и 68020-68060</h4>

<p>Есть отличие, если регистр, используемый в
случае адресации с предварительным уменьшением
адреса до выполнения команды (RL) также содержится
в списке регистров. На процессорах 68020-68060
значение, записанное в память является исходным
значением регистра, уменьшенным на размер
операции. На процессорах же 68000 и 68010 записывается
исходное значение (не уменьшенное). <br>
Так как эта инструкция редко используется, то на
данный момент не замечено ни одной программы,
испытывающей поблемы из-за описанных различий.</p>

<h3>Общие принципы написания патчей</h3>

<ul>
  <li>Не изменяйте состояние регистров (таких как VBR
    или CACR), присутствующих&nbsp; на старших моделях
    процессоров. С точки зрения человека,
    программирующего Slave-модуль, VBR всегда равен 0,
    даже если он был перемещен, потому что
    эмулируются &nbsp; автовекторы (а также и Traps при
    условии, что установлен флаг <a href="../autodoc.html#WHDL_EmulTrap">WHDL_EmulTrap</a>).
    Биты в CACR различны для каждого процессора. Есть
    только один надёжный способ изменять <a href="cache.html">Cache</a>
    - использовать <a href="../autodoc.html">resload_SetCACR/SetCPU</a>
    и <strong>bitdef</strong>'ы из 'exec/execbase.i' и 'whdload.i'. Надо также
    убрать все обращения к этим регистрам из
    установленной программы, иначе WHDLoad не будет
    правильно работать! </li>
  <li>Никогда не изменяйте образы дисков. Это полезно
    в случае, если кто-то захочет запустить программу
    дискеты, то ему нужно будет просто записать образ
    обратно на диск (при условии, что программа
    работает без использования каких-либо патчей,
    хотя, нельзя сказать что такое бывает в
    большинстве случаев). </li>
  <li>Никогда не используйте оригинальный код из
    программы непосредственно в slave-модуле (с точки
    зрения защиты авторских прав). </li>
  <li>Включайте кэши только если вы уверены, что это
    заработает на всех процессорах. </li>
  <li>Насколько это возможно, используйте как можно
    меньше памяти для <strong><a href="../autodoc.html#ws_BaseMemSize">ws_BaseMemSize</a></strong>. У некоторых
    людей в конце Chip-памяти висят резидентные
    программы, так что это поможет использовать
    только <tt>$1f0000</tt>, вместо $<tt>200000</tt> и WHDLoad сможет
    использовать всю зарезервированную память. </li>
</ul>

<h3>Советы и маленькие хитрости</h3>

<h4>Что лучше использовать: образы дисков или
файлы?</h4>

<p>Иногда перед вами будет стоять выбор, что
использовать, образы дисков или файлы. Оба
способа имеют свои преимущества. Использование
образов диска, как правило, более легкий и более
быстрый способ создать slave-модуль. Но реальные
файлы значительно проще кэшировать (если очень
мало памяти или память фрагментирована).
Занимаемое место на жестком диске также будет
меньше в случае с реальными файлами по сравнению
с использованием образов дисков. Рекомендуется
использовать образы дисков только, если файлов
очень много (более 30-ти).</p>

<p><br>
</p>
</body>
</html>
