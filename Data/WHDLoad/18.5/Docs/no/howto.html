<HTML>
<HEAD>
<TITLE>Programmere WHDLoad</TITLE>
<meta name="DC.Language" content="nb">
<meta http-equiv="content-language" content="nb">
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<!-- $Id: howto.html 1.2 2009/02/05 20:38:15 wepl Exp wepl $ -->
</HEAD>
<BODY>
<h3>Skjematisk kjøreflyt</h3>
<p>Den følgende tabellen viser programflyten når et WHDLoad-installert program
kjøres. Jeg håper den hjelper til med å skjønne hvordan WHDLoad virker, og
hvordan WHDLoad, Slaven og det installerte programmet samarbeider.</p>
<table cellpadding=3>
  <tr>
    <td valign=top>BRUKEREN</td>
    <td>
      <ul>
        <li>starter demoen eller spillet ved å klikke et Ikon eller ved å starte
            WHDLoad via kommandolinjen
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>Operativsystemet</td>
    <td valign=top>
      <ul>
        <li>laster WHDLoads kjørefil og starter den
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>WHDLoad</td>
    <td>
      <ul>
        <li>kontrollerer programvaren og maskinvare-miljøet
        <li>laster og kontrollerer Slaven
        <li>tildeler nødvendig minne til det installerte programmet
		<li>hvis <a href="opt.html#Preload">Preload/S</a> er satt på, lastes
			diskbilder og filer inn i RAM (så langt ledig minne rekker)
        <li>slår av OS (stenger for multitasking og avbrudd, degraderer
			grafisk maskinvare til OCS, setter all maskinvare til definerte verdier)
        <li>hopper til Slaven
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>Slave</td>
    <td>
      <ul>
        <li>laster hoved-kjørefilen til det installerte programmet ved å kalle en
			WHDLoad-funksjon (f.eks <a
            href="../autodoc.html#resload_DiskLoad">resload_DiskLoad</a> eller <a
            href="../autodoc.html#resload_LoadFile">resload_LoadFile</a>)
        <li>oppdaterer kjørefilen (slik at programmet laster data via Slaven,
			fikser kompatibilitetsproblemer, muliggjør avslutning av programmet)
        <li>kjører hovedkjørefilen
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>Installert program</td>
    <td>
      <ul>
        <li>gjør sine ting
        <li>ved lasting av data fra disk vil den kalle Slaven (fordi Slaven
			har oppdatert den for dette), og Slaven vil kalle opp
			WHDLoad, og WHDLoad vil delvis tillate OS å laste dataene
			(hvis ikke dataene er <a href="opt.html#Preload">Preload</a>-et),
			så retur, retur og det installerte programmet fortsetter
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>BRUKEREN</td>
    <td>
      <ul>
        <li>avslutter programmet ved å trykke <a
            href="opt.html#QuitKey">QuitKey</a>
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>Slaven</td>
    <td>
      <ul>
        <li>returnerer til WHDLoad ved å kalle <a
            href="../autodoc.html#resload_Abort">resload_Abort</a>
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>WHDLoad</td>
    <td>
      <ul>
        <li>slår på OS igjen (tilbakestiller maskinvare-registre, skjerm og minne)
        <li>frigjør alle tildelte ressurser
        <li>returnerer til OS'et
      </ul>
    </td>
  </tr>
</table>
<h3>Hvordan installere en enkel en-disketts sporlaster</h3>
Dette er en veldig liten og kort steg for steg guide for hvordan lage en installerer
med WHDLoad. Guiden reflekterer et ideelt, enkelt tilfelle. I den virkelige verden vil
sannsynligvis et slikt tilfelle ikke forekomme. For spesielle tilfeller og problemer, les
de påfølgende kapitlene.
<ol>
  <li>Forarbeid
    <ul>
      <li>Lag en skuff som skal inneholde alle filer.
      <li>Lag et disbilde med <A HREF="dic.html"> DIC </A> ii denne skuffen.
      <li>Lag en <a href="opt.html#optwb">#?.info</a>-fil med "WHDLoad"
          som &lt;Default Tool&gt; og en Tooltype "SLAVE=#?" som inneholder
          navnet på Slaven. (eller rett og slett kopier ikonet fra en 
		  Eksempelinstallering, og slå av alle tooltyper unntatt "SLAVE=").
    </ul>
  <li>Slaven<br>
	For å skrive slaven trenger vi følgende informasjon:
    <ol>
      <li>Hvor på disken finnes hovedkjørefilen?
      <li>Hvor i hovedkjørefilen finnes disklasteren?
    </ol>
	For å få denne informasjonen må vi først analysere startblokken. Stort sett
	vil hovedkjørefilen lastes herfra via exec.DoIO(). Noen ganger
	ligger det en spesiell sporlaster i startblokken. Nå skriver vi en Slave som
	simulerer startblokken og laster hovedkjørefilen fra diskbildet.
	Så trekker vi ut hovedkjørefilen fra bildet eller en
	<a href="dump.html#memory">memory dump</a>. Etter dette må vi finne lasteren
	i kjørefilen. En rask metode er å søke etter mønsteret
    <tt>$AAAAAAAA</tt> (brukt av MFM dekoding) med en hex-redigerer. Så klippes området
	ut (+/- <tt>$1000</tt> byte), disassembler den, og søker etter starten av rutinen.
	Forstå parameterlisten. Nå lager vi en kode for Slaven som oppdaterer
	denne lasterutinen slik at alle kall til lasteren blir omdirigert til
	Slaven. Slaven vil så tilpasse parameterene og kalle opp WHDLoad-funksjonen <a
    href="../autodoc.html#resload_DiskLoad">resload_DiskLoad</a>.
  <li>I det ideelle tilfellet er installeren nå ferdig.<br>
Det eneste som gjenstår er å lage et pent Ikon. Trekk ut to bilder ved å bruke
<a href="snoop.html">søkefunksjonen</a> i WHDLoad og <a href="sp.html">SP</a>
eller en fryser eller U.A.E. og bygg ikonet. 16-fargers <a
href="ftp://ftp.wustl.edu/pub/aminet/pix/mwb/RomIcons10.lha">RomIcon</a>-palett anbefales.
</ol>
<h3>Mulige problemer og spesialtilfeller</h3>
<h4>Ikke-standard spor-laster</h4>
Noen programmer har sitt eget diskett-format. Dette betyr at <a
href="dic.html">DIC</a> ikke er i stand til å lage diskbildene. For å lage
filer eller bilder fra slike disketter anbefales <a href="rawdic.html">RawDIC</a>.
Les dokumentasjonen for RawDIC for mer informasjon.

<h4>Flere disketter</h4>
Hvis programmet bruker mere enn en diskett må slaven omdirigere diskett-tilgangen
til det passende diskbildet. Av og til er ikke dette så lett. Noen
programmer støtter mere enn en stasjon, så man kan bruke stasjonsnummeret for
valg av diskett. De fleste programmer benytter en ID på hver diskett for å
skille dem. I dette tilfellet, bruk en variabel som inneholder diskettnummeret,
og ved hvertilgang til diskett-ID'en (avgjør en slik tilgang ved å analysere
parameterene til disklasteren) øk variabelen (hvis siste diskett er nådd, reduser
variabelen). Så håper man at lasteren vil lese diskett-ID'en om og om igjen til
den riktige disketten finnes. Kanskje det er en forespørsel fra programmet om at
brukeren må sette inn riktig diskett, isåfall slå den av.

<h4>Highscore-lagring</h4>
Ikke så mye å si her. Bruk <a
href="../autodoc.html#resload_SaveFile">resload_SaveFile</a> for å skrive det passende
minneområdet til disk. Hvis man vil, krypter det litt så lamere ikke tukler for
lett med det. Det anbefales ikke å skrive direkte til diskbilder (med
<a href="../autodoc.html#resload_SaveFileOffset">resload_SaveFileOffset</a>), for hvis
noe går galt (f.eks. en kræsj) er det mulig at bildene blir ødelagt.

<h4>Lagrede spill (savegames)</h4>
Håndter lagring av spill på samme måte som highscore.

<h4>Tilgang til operativsystemet</h4>
Når slaven og det installerte programmet kjøres, eksisterer absolutt ikke noe OS,
og det gir absolutt ingen mening å få tilgang til OS'et. Derfor må alle
forsøk på tilgang fra det installerte programmet slås av. Hvis det ikke er for
mange av dem, og de ikke gir mening i WHDLoad-miljøet (som exec.Disable() eller 
exec.SuperState()) rett og slett NOP (<tt>$4e71</tt>) dem. Hvis tilgangene har
en viktig funksjon (som exec.DoIO()), omdiriger dem til Slaven og emuler dem.
Hvis det er mange av dem, lag en enkel exec.library i et ubrukt minneområde
emulate them. If there are loads of them, create a simple exec.library in an
(initialiser longword ved addresse <tt>$4</tt>). Du kan sjekke kilden til Oscar.slave,
som emulerer exec.AllocMem(). For å oppdage tilganger til OS'et, settes den initielle
execbase <tt>$f0000001</tt> med den intensjon at alle rutiner som liker å bruke execbase
lager er "Address Error"-unntak.<br>
Hvis det er tung bruk av OS-funksjoner, bruk en av kickemu-pakkene som finnes
i whdload-dev pakken. Det er en pakke for Kick 1.3
('src/sources/whdload/kick13.s') og en for Kick 3.1 ('src/sources/whdload/kick31.s').
Disse pakkene krever et originalt kickstart-bilde og vil lage et komplett OS-miljø
inne i WHDLoad. Konsulter også de relevante medfølgende readme-filene for mer
informasjon.

<h3>Vanlige kompatibilitetsproblemer</h3>
<h4>Begrenset addresseplass på 68000/68010/68ec020</h4>
På disse prosessorene er addresseplassen begrenset til 16 MB (<tt>$000000...$ffffff</tt>) 
siden disse CPU'ene bare har 24 adresselinjer. Et resultat av dette er at all tilgang
til høyere adresser skjer på de lavere 16 MB ved å ignorere de mest signifikante 8 bit'er.
Noen programmer bruker disse bit'ene til å lagre data, eller glemmer rett og slett å
tømme dem. På en prosessor med full 4 GB adresseplass som
68020/680ec30/68030/68040/68060 vil ikke dette virke, fordi de fullstendige 32-bits addressene
vil få tilgang.<br>
For å løse dette må man fikse alle disse tilgangene og omdirigere dem til passende adresser.<br>
Noen ganger kan grunnen til tilgang til merkelige adresser være en ikke-initialisert
peker. I så tilfelfelle kan det hjelpe å tømme <tt>$400</tt> - <a href="../autodoc.html#ws_BaseMemSize">ws_BaseMemSize</a>.

<h4>Forskjellige stakkrammer (stackframes) på hver prosessor</h4>
Stakkrammene som lages av prosessorer ved avbrudd og unntak er forskjellige
for medlemmene av 68k-familien. På en 68000 er stakkrammen 6 byte, bortsett
ved buss- og adressefeil. Stakkrammen inneholder den lagrede SR ved (a7) og
den lagrede PC ved (2,a7). På alle andre prosessorer (68010+) er
minste stakkramme 8 byte og inneholder i tillegg vektornummeret som et word
ved (6,a7). Dette fire-word stakkrammeformatet <tt>$0</tt> er laget for "Trap #xx"
og avbrudd på 68010-68060. Stakkrammene for andre unntak er forskjellige
på hver prosessor. RTE-instruksjonen virker forskjellig på 68000 mot 68010+.
På en 68000 tilbakekaller den bare SR og PC og fortsetter programkjøringen
ved den avbrutte adressen. På en 68010+ vil den i tillegg frigjøre stakkrammen
avhengig av stakkrammeformat. <br>
Noen programmer dytter (push) en adresse (PC) og en SR og kjører sp en RTE-instruksjon.
Dette virker bare på en 68000, på en 68010+ vil dette ha uforutsigbare resultater.
<br>Hvis et program gjør dette, må man fikse dette. Noen ganger er det nok å
erstatte RTE'en med en RTR.

<h4>MOVEM.x RL,-(An) på 68000/010 og 68020/030/040</h4>
Det er en forskjell på om registeret brukt i førreduseringsmodus (RL) også finnes i registerlisten.
For 68020, 68030 og 68040 er verdien skrevet i minne den initielle registerverdien
redusert med størrelsen på operasjonen. 68000 og 68010 skriver initiell
registerverdi (uredusert) <br>
Siden slik konstruksjon ikke er særlig nyttig er det ingen nåværende programvare
som er kjent med å ha problemer med dette.

<h3>Generelle retningslinjer for å skrive installerere</h3>
<ul>
<li>Ikke endre CPU-registre som finnes i høyere prosessorer som VBR eller CACR. VBR er alltid 0
fra Slaveprogrammererens synsvinkel, selv om det er flyttet fordi Autovektorer
(og feller (Traps) hvis flagget <a href="../autodoc.html#WHDL_EmulTrap">WHDL_EmulTrap</a> er satt)
emuleres. Bit'ene i CACR'en er forskjellige for hver prosessor. Det er bare én gyldig måte å endre 
<a href="cache.html">bufrene</a> på, bruk <a href="../autodoc.html">resload_SetCACR/SetCPU</a>
og bitdef'ene fra 'exec/execbase.i' og 'whdload.i'. I tillegg må alle ting i programmet som installeres
som bruker disse registrene slås av eller omgås, ellers vil ikke WHDLoad virke!
<li>Endre aldri på diskbildene. Dette har den fordelen at hvis noen ønsker å kjøre programmet
fra diskett trenger man bare skrive bildet tilbake til disketten (forutsatt at programmet kjører
uten diverse oppdateringer, stort sett ikke det vanligste tilfellet...)
<li>Bruk aldri originale ting fra programmet direkte i Slaven (kopirettighetsproblemer). 
<li>Slå på bufre kun hvis du sikker på at det kjører på alle prosessorer.
<li>Bruk så lite minne som mulig for <a href="../autodoc.html#ws_BaseMemSize">ws_BaseMemSize</a>. Noen folk har informasjon (resident tags)
på slutten av Chip-minnet, så det hjelper å bare bruke <tt>$1f0000</tt> istedet for <tt>$200000</tt>
og WHDLoad kan bruke absolutt tildelt minne.
</ul>
<h3>Tips &amp; triks</h3>
<h4>Hva er best, bruke diskbilder eller filer?</h4>
Noen ganger har man valget om å bruke diskbilder eller ekte filer. Begge valg har
sine fordeler. Bruk av diskbilder er som oftest den enkleste og raskeste måten p
lage Slaven. Men ekte filer bufres lettere (hvis det er veldig lite minne eller
minnet er fragmentert). Nødvendig diskplass er også mindre med ektre filer enne med
diskbilder. Man bør bare bruke diskbilder om det er mange filer (mer enn 30).
</BODY>
</HTML>
