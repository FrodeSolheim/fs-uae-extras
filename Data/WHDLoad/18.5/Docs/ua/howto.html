<html>

<head>
<title>Programming WHDLoad</title>
<meta name="DC.Language" content="ua">
<meta http-equiv="content-language" content="ua">
<meta http-equiv="content-type" content="text/html; charset=windows-1251">
<!-і $Id: howto.html 1.4 2009/02/05 20:38:15 wepl Exp wepl $ -і>
</head>

<body>

<h3>Схематичний опис роботи програми</h3>

<p>Наступна таблиця показує процес
виконання програми, коли запускається
програма, установлена за допомогою WHDLoad. Я
сподіваюсь, що це допоможе зрозуміти, як працює WHDLoad
і як WHDLoad, slave-модуль і встановлена програма
взаємодіють між собою. </p>

<p>&nbsp;</p>

<table cellpadding="3">
<tbody>
  <tr>
    <td valign="top">КОРИСТУВАЧ</td>
    <td><ul>
      <li>запускає демо або гру, клацаючи на іконку або
        запускаючи WHDLoad через командний рядок </li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top">Операційна Система</td>
    <td valign="top"><ul>
      <li>завантажує WHDLoad і виконує запуск </li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top">WHDLoad</td>
    <td><ul>
      <li>перевіряє програмне середовище й апаратні
        засоби </li>
      <li>завантажує й перевіряє slave-модуль </li>
      <li>резервує необхідну кількість пам'яті для
        установленої програми </li>
      <li>якщо активізовано опцію <a href="opt.html#Preload">Preload/S</a>,
        те в оперативну пам'ять завантажуються образи диска
        і файли (наскільки дозволяє вільна пам'ять) </li>
      <li>відключає OS (відключає багатозадачність й
        преривання, перемикає графіку на режим OCS,
        ініціалізує всі апаратні засоби,
        використовуючи задані значення)</li>
      <li>робить перехід на виконання slave-модуля</li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top">Slave-модуль</td>
    <td><ul>
      <li>завантажує головний виконуваний файл
        установленої програми, викликаючи функцію WHDLoad
        (наприклад, <a href="../autodoc.html#resload_DiskLoad">resload_DiskLoad</a> або <a
        href="../autodoc.html#resload_LoadFile">resload_LoadFile</a>) </li>
      <li>виправляє виконуваний файл (щоб програма
        завантажила свої дані через slave, усуває
        проблеми несумісності, активізує функцію
        виходу із програми) </li>
      <li>запускає головний виконуваний файл, що,</li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top">Установлена програма</td>
    <td><ul>
      <li>виконується</li>
      <li>при завантаженні даних з диска, викликає
        slave-модуль (тому що slave-модуль виправив
        файл, що виконується,), slave-модуль викликає WHDLoad, і WHDLoad
        частково активізує OS щоб завантажити дані
        (тільки якщо дані не були попередньо
        завантаженні - див.&nbsp;<a href="opt.html#Preload">Preload</a>), потім
        повертається у встановлену програму й
        програма продовжує виконання </li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top">КОРИСТУВАЧ</td>
    <td><ul>
      <li>виходить із програми, натискаючи клавішу виходу <a
        href="opt.html#QuitKey">QuitKey</a></li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top">Slave-модуль</td>
    <td><ul>
      <li>повертається в WHDLoad, викликаючи <a href="../autodoc.html#resload_Abort">resload_Abort</a></li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top">WHDLoad</td>
    <td><ul>
      <li>перезапускає OS (відновлює стан
        регістрів, пам'яті, дисплея) </li>
      <li>звільняє всі зайняті ресурси </li>
      <li>робить повернення в OS</li>
    </ul>
    </td>
  </tr>
</tbody>
</table>

<h3>Як встановити диск, який використовує трековий
завантажник (trackloader)</h3>

<p>Це зовсім короткий покроковий опис того, як створити патч, що використає WHDLoad.
  Даний пункт пояснює найпростіший варіант. У реальності такого варіанта швидше
  за все не буде. У наступних главах, будуть окремо описані особливі випадки й
  проблеми, з якими ви можете зустрітися.
<ol>
  <li>Попередня підготовка <ul>
      <li>Створіть папку, у якій будуть перебувати всі
        файли. </li>
      <li>Створіть у цій же папці образ диска, використовуючи <a
        href="dic.html">DIC</a>.</li>
      <li>Створіть <a href="opt.html#optwb">*? .info</a> файл, у якому інструментом
        за замовчуванням є &quot;<strong>WHDLoad</strong>&quot; &nbsp; і параметром
        (Tooltype) &quot;<strong>SLAVE=</strong>#?&quot;, де &quot;#?&quot; -
        ім'я slave-модуля (або просто скопіюйте іконку з інсталяційного приклада
        й відключіть всі параметри (Tooltypes) крім &quot;SLAVE=&quot;).</li>
    </ul>
  </li>
  <li>Slave-модуль<br>
    Для створення slave-модуля нам необхідна наступна
    інформація:<br>
    &nbsp;&nbsp;&nbsp; 1) Де на диску розташований головний виконуючий файл?<br>
    &nbsp;&nbsp;&nbsp; 2) Де усередині головного виконуючого файлу розташовується
    завантажник диска?<br>
    Щоб одержати цю інформацію ми спочатку аналізуємо завантажувальний блок (bootblock).
    Як правило, головний виконуючий модуль, що, завантажується звідси, використовуючи
    функцію <strong>exec.DoIO().</strong> Іноді в завантажувальному блоці присутній
    завантажник доріжки (trackloader). Тепер ми напишемо Slave-модуль, який буде
    емулювати завантажувальний блок й завантажувати головний виконуючий модуль
    і образи диска. Зараз нам необхідно витягти головний виконуючий модуль з образа
    диска або з <a
    href="dump.html#memory">дампа пам'яті</a>. Після цього нам потрібно знайти
    завантажник у головному виконуючому файлі. Найшвидший шлях полягає в тому,
    щоб спробувати знайти у HEX-редакторі послідовність <tt>$AAAAAAAA</tt> (використовується
    MFM-декодуванням). <font color=#000000>Виріжте</font> знайдену область із
    захватом +/- $1000 байт, дизасемблюйте, і шукайте початок процедури. Коли
    завантажник буде знайдений, розберіться які параметри завантаження він використовує
    (адреса завантаження, довжина). Тепер ми створюємо код для slave-модуля, який
    виправить цю процедуру завантажника, і який буде обробляти всі запити переадресовуючи
    їх slave-модулю. Slave-модуль буде коректувати параметри завантаження й викликати
    функцію WHDLoad'а <a
    href="../autodoc.html#resload_DiskLoad">resload_DiskLoad</a>.</li>
  <li>У випадку такого ідеального варіанта, slave-модуль уже готовий.<br>
    Тепер залишилося єдине - створити гарну іконку. Сграбте дві картинки, використовуючи
    опцію <a
    href="snoop.html">Snoop</a> програми WHDLoad й <a href="sp.html">SP</a> або
    системний монітор, або UAE, і створіть іконку.&nbsp;Рекомендується використовувати
    16 кольорову <a
    href="ftp://ftp.wustl.edu/pub/aminet/pix/mwb/RomIcons10.lha">RomIcon</a> палітру.</li>
</ol>

<h3>Можливі проблеми й особливі випадки</h3>

<h4>Нестандартний завантажник доріжки</h4>

<p>Деякі програми використовують свій власний формат диска. Це означає, що <a
href="dic.html">DIC</a> не в змозі створити образ такого диска. Щоб прочитати
  файли з такого диска або створити його образ, рекомендується використати <a
href="rawdic.html">RawDIC</a>. За подробицями звертайтеся до документації програми
  <strong>RawDIC</strong>. </p>

<h4>Програма використовує кілька дисків</h4>

<p>Якщо програма використовує, то більше чим один диск, те slave-модуль повинен
  переадресувати доступи до дисків до відповідного файлу образа. Іноді це не легко.
  Деякі програми підтримують більше одного дисководу, так що ви можете використати
  номер дисководу для вибору потрібного диска. Більшість програм використовує
  ідентифікатор (наприклад назва) на кожному диску, щоб розрізняти їх. У цьому
  випадку, використайте змінну, котра містить номер диска, і при кожному зверненні
  до ідентифікатора диска (визначайте такий доступ, аналізуючи параметри для завантажника
  диска) збільшуйте змінну (а якщо досягнуто останнього диска, то зменшуйте її),
  у надії на те, що завантажник буде перечитувати ідентифікатори знову й знову
  поки не виявить потрібний диск. Деякі програми видають запит, щоб користувач
  вставив правильний диск - відключіть цей запит. </p>

<h4>Збереження таблиці рекордів (Highscore)</h4>

<p>Ну, що тут казати. Використовуйте функцію <a
href="../autodoc.html#resload_SaveFile">resload_SaveFile</a>, щоб записати відповідну
  область пам'яті на диск. Якщо хочете, то можете ще й зашифрувати її так, щоб
  &quot;чайникам&quot; було не легко її виправити. Не рекомендується робити запис
  безпосередньо в образ диска (використовуючи функцію <a href="../autodoc.html#resload_SaveFileOffset">resload_SaveFileOffset</a>)
  тому, що якщо щось піде не так, як треба (наприклад, яка-небудь помилка або
  зависання), то можливо, що образ диска буде ушкоджений. </p>

<h4>Збереження прогресу гри (Savegames)</h4>

<p>Запис прогресу гри здійснюється тими ж способами, що й у випадку з таблицею
  рекордів.</p>

<h4>Доступи до операційної системи</h4>

<p>Під час роботи slave-модуль і встановлена програма не повинні мати ніяких звернень
  до OS! Тому всі звернення з установленої програми повинні бути відключені або
  переспрямовані. Якщо їх не так багато й вони не потрібні при роботі через WHDLoad
  (типу <strong>exec.Disable()</strong> або <strong>exec.SuperState()</strong>),
  то просто можна змінити їх командою <strong>NOP</strong> (<strong><tt>$4e71</tt></strong>).
  Якщо виклики несуть важливу функцію (типу <strong>exec.DoIO()</strong>), переадресуйте
  їх slave-модулю, і емулюйте їх. Також можете створити просту exec.library в
  невикористаній області пам'яті (проініціалізируйте довге слово за адресою <strong><tt>$4</tt></strong>).
  Подивитеся як це зроблено у вихідному тексті для модуля &quot;Oscar.slave&quot;,
  що емулює <strong>exec.AllocMem()</strong>. Для виявлення таких викликів OS,
  виставте початковий execbase в <strong><tt>$f0000001</tt></strong> з тією метою,
  щоб всі програми, які можуть використовувати execbase, видали &quot;Помилку
  Адреси&quot;.<br>
Якщо емулювати функції OS занадто складно, тоді
просто використайте один з kickemu-пакетів, які
можуть бути знайдені в дистрибутиві whdload-dev. Там
є один пакет для Kick 1.3 ('src/sources/whdload/kick13.s'') і один
для Kick 3.1 ('src/sources/whdload/kick31.s''). Ці пакети вимагають
оригінального образа кікстарта й створюють
повноцінну OS в WHDLoad. Див. також файли readme, які
поставляються в комплекті із цими пакетами</p>

<h3>Проблеми сумісності</h3>

<h4>Обмежений адресний простір на
68000/68010/68ec020</h4>

<p>На цих процесорах адресний простір обмежено розміром 16 Мб (<tt>$000000...
  $ffffff</tt>), тому що центральний процесор має тільки 24 адресні лінії. У результаті
  всі доступи до більш високих адрес виконуються до адрес нижче 16 Мб, просто
  ігноруючи адреси старші 8 біт. Деякі програми використовують ці біти для зберігання
  даних або просто забувають очищати їх. На процесорах з повним 4Гб адресним простором,
  типу 68020/680ec30/68030/68040/68060 це не відбуватиметься, тому що звернення
  буде йти до повної 32-х бітної адреси.<br>
  Для рішення цієї проблеми, ви повинні підкоректувати ці виклики й перенаправляти
  їх на відповідні адреси.<br>
Іноді причиною доступу до дивних адрес може
бути непроініціалізований покажчик. У цьому
випадку може допомогти очищення <strong><tt>$400</tt></strong> - <strong><a href="../autodoc.html#ws_BaseMemSize">ws_BaseMemSize</a></strong>.
</p>

<h4>Різний стековий фрейм на різних
процесорах</h4>

<p>Стекові фрейми, створені процесором після преривання і подій, різні для різних
  процесорів класу 68ДО. На 68000 стековий фрейм становить 6 байт, за винятком
  &quot;Помилки Адреси&quot; і &quot;Помилки Шини&quot;. У стековому фреймі перебуває
  збережене значення SR в (a7) і PC в (2,a7). На всіх інших процесорах (68010
  +) мінімальний стековий фрейм становить 8 байт і додатково містить номер вектора
  як слово в (6,a7). Цей формат стекового фрейму $0, що складається з чотирьох
  слів, створений для &quot;Trap #xx&quot; і переривань на 68010-68060. Стекові
  фрейми для інших подій різні на кожному процесорі. Інструкція RTE на 68000 працює
  інакше чим на 68010+. На 68000 вона просто відновлює SR й PC і продовжує виконання
  програми з перерваної адреси. На 68010 + вона додатково звільняє стековий фрейм
  в залежності від його формату. <br>
  Деякі програми проштовхують (записують у стік?) адресу (PC) і SR, а потім виконують
  інструкцію RTE. Це працює тільки на процесорах 68000, а на 68010+ результат
  непередбачений. <br>
Якщо програма працює таким чином, ви повинні
виправити це місце. Іноді буває досить
замінити RTE на RTR. </p>

<h4>MOVEM.x RL,-(An) на 68000/010 й 68020/030/040</h4>

<p>Є відмінність, якщо регістр, що використовується у випадку адресації з попереднім
  зменшенням адреси, то виконання команди (RL) також утримується у списку регістрів.
  На процесорах 68020, 68030, 68040 значення, записане у пам`ять є вихідним значенням
  регістра, зменшеним на розмір операції. На процесорах же 68000 й 68010 записується
  вихідне значення (не зменшене). <br>
  Оскільки ця інструкція рідко використовується, то на даний момент не помічено
  ні однієї програми, яка б мала проблеми через описані розходження.</p>

<h3>Загальні принципи написання патчей</h3>

<ul>
  <li>Не змінюйте стан регістрів (таких як VBR або CACR), присутніх&nbsp; на старших
    моделях процесорів. З погляду людини, яка програмує Slave-модуль, VBR завжди
    дорівнює 0, навіть якщо він був переміщений, тому що емулюються автовектори
    (а також Traps при умові, що встановлено прапорець <a href="../autodoc.html#WHDL_EmulTrap">WHDL_EmulTrap</a>).
    Біти в CACR різні для кожного процесора. Є тільки один надійний спосіб змінювати
    <a href="cache.html">Cache</a> - використати <a href="../autodoc.html">resload_SetCACR/SetCPU</a>
    і <strong>bitdef</strong>'и з 'exec/execbase.i' й 'whdload.i'. Треба також
    забрати всі звертання до цих регістрів з установленої програми, інакше WHDLoad
    не буде правильно працювати! </li>
  <li>Ніколи не змінюйте образи дисків. Це корисно у випадку, якщо хтось захоче
    запустити програму з дискети, то йому потрібно буде просто записати образ
    знову на диск (за умови, що програма працює без використання яких-небудь патчей,
    хоча, не можна сказати що таке буває в більшості випадків). </li>
  <li>Ніколи не використовуйте оригінальний код з програми безпосередньо в slave-модулі
    (з погляду захисту авторських прав). </li>
  <li>Включайте кеші тільки якщо ви впевнені, що це запрацює на всіх процесорах.
  </li>
  <li>Наскільки це можливо, використовуйте як можна менше пам'яті для <strong><a href="../autodoc.html#ws_BaseMemSize">ws_BaseMemSize</a></strong>.
    У деяких людей наприкінці Chip-пам'яті висять резидентні програми, так що
    це допоможе використати тільки <tt>$1f0000</tt>, замість $<tt>200000</tt>
    й WHDLoad зможе використати всю зарезервовану пам'ять. </li>
</ul>

<h3>Поради й маленькі хитрощі</h3>

<h4>Що краще використовувати: образи дисків або файли?</h4>

<p>Іноді перед вами буде стояти вибір, що використовувати, образи дисків або файли.
  Обидва способи мають свої переваги. Використання образів диска, як правило,
  більше легкий і більше швидкий спосіб створити slave-модуль. Але реальні файли
  значно простіше кешувати (якщо дуже мало пам'яті або пам'ять фрагментирована).
  Зайнятого місця на жорсткому диску також буде менше при роботі з реальними файлами
  в порівнянні з використанням образів дисків. Рекомендується використати образи
  дисків тільки в тому випадку, якщо файлів дуже багато (більше 30-ти).</p>

<p><br>
</p>
</body>
</html>
