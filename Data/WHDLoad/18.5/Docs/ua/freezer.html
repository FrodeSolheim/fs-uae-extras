<html>

<head>
<title> Системні монітори / Відладчики</title>
<meta name="DC.Language" content="ua">
<meta http-equiv="content-language" content="ua">
<meta http-equiv="content-type" content="text/html; charset=windows-1251">
<!-і $Id: freezer.html 1.4 2011/09/04 23:01:44 wepl Exp wepl $ -і>
</head>

<body>

<h3>Системні монітори / Відладчики</h3>

<p>Існує безліч різних програм для
налагодження. Їхнє використання може допомогти  в процесі розробки й налагодження програм.
 WHDLoad&nbsp; прямо підтримує такі як HRTmon й
ThrillKill. Інші можуть використовуватися через
параметр <a href="opt.html#NoTrapHandler">NoTrapHandler/S</a> (отут
звичайно є свої мінуси). Якщо ви хочете пряму
підтримку інших способів, то просто зв'яжіться
із мною і я включу цю підтримку, якщо це
Вам здається можливим. При старті WHDLoad
перевіряє, чи активний якийсь із моніторів що підтримується. Якщо хоча б один з відомих
моніторів буде виявлений, то WHDLoad робить
спеціальні дії. Якщо WHDLoad використовує MMU, то
оголошена пам'ять використовується монітором й
кешується WriteThrough. У процесі роботи ігор/демо
WHDLoad пересилає всі NMI-виключення NMI-вектору,
записуючи їх у таблицю векторів монітора.
Додатково, якщо VBR переміщений за допомогою WHDLoad
(опція <a href="opt.html#NoVBRMove">NoVBRMove/S</a> не включена, і
процесор не нижче 68010), то при кожному перериванні
буде перевірятися чи не натиснута на клавіатурі
клавіша <a href="opt.html#FreezeKey">FreezeKey</a>. І якщо клавішу
натиснуто, то WHDLoad&nbsp;обробляє натискання,
перетворює stackframe в NMI stackframe і входить у монітор
через його обробник NMI. </p>

<h4>HRTmon</h4>

<p>Виявлення в пам'яті повинні бути досить
стабільними. Я думаю, що це буде також
працювати й з майбутніми версіями програми. Будьте
уважні, якщо WHDLoad використовує MMU: не робіть
звертань з HRTmon до області за межами BaseMem - це
викличе помилку, тому що HRTmon не зможе обробити
Access Fault Exception.</p>
<p>У властивостях HRTmonPrefs, обов'язково включить 'No VBR move', інакше не зможете ввійти в монітор, під час роботи WHDLoad. </p>
<p>Після повернення з активованого HRTmon у запущену під WHDLoad програму, зображення на дисплеї може бути "битим", тому що HRTmon перезаписує деякі регістри. Ви можете цього уникнути, якщо перед поверненням укажете HRTmon коректні значення, наприклад, <tt>'e $100 $5200'</tt> для 32-кольорового режиму екрана. </p>
<p>HRTmon вбудований в WinUAE може бути виявлен тільки якщо HRTmon був
активований принаймні один раз (натискання клавіші PgUp). Для пошука монітора, NMI вектор, який використовується WHDLoad, буде встановлен після першої активації.</p>

<h4>ThrillKill</h4>

<p>У відладчику відсутня яка-небудь сигнатура,
тому використаються деякі  кодові порівняння.
Тому процес визначення може не працювати з
іншими версіями. </p>
</body>
</html>
