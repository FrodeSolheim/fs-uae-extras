<html>

<head>
<title> Використання функції resload_Protect#?</title>
<meta name="DC.Language" content="ua">
<meta http-equiv="content-language" content="ua">
<meta http-equiv="content-type" content="text/html; charset=windows-1251">
<!-і $Id: prot.html 1.4 2009/02/05 20:38:15 wepl Exp wepl $ -і>
</head>

<body>

<h3>Використання функції resload_Protect *?</h3>

<h4>Теорія</h4>

<p>Є різні ситуації, при яких&nbsp; було б дуже корисно одержувати інформацію
  про те, що установлена програма звертається до певних ділянок пам'яті. За допомогою
  функції <a
href="../autodoc.html">resload_Protect *?</a>&nbsp; можна захищати ділянки
  пам'яті від читання й/або запису процесором. Захист полягає в тому, що кожен
  доступ до такої захищеної ділянки ініціює виняткову подію &quot;Помилка Доступу&quot;,
  яка створить відповідне вікно з повідомленням від WHDLoad. Якщо ви ставите область
  пам'яті під захист, використовуючи функцію <a
href="../autodoc.html">resload_Protect *?</a>, то WHDLoad змінить затронуті
  дескриптори сторінок у списку перекладу диспетчера пам'яті (MMU). Тепер при
  кожному доступі до захищеної сторінки центральний процесор буде ініціювати виняткову
  подію &quot;Помилка Доступу&quot;. Оброблювач виняткових подій усередині WHDLoad
  перевірить його причину. Якщо причиною був доступ до захищеної <a
href="mmu.html">сторінки</a>, але доступ не торкнув захищену ділянку, то цей доступ
  буде емулюватися, і продовжиться нормальне виконання програми. Інакше, WHDLoad
  закінчить роботу і видасть відповідне вікно з повідомленням. Якщо відбувається
  доступ до інструкції (тобто центральний процесор намагається завантажити код),
  то це завжди буде емулюватися, або інакше кажучи, функція <a
href="../autodoc.html">resload_Protect *?</a> стосується тільки читання
  й запису даних. Факт в тому, що кожен доступ до захищеної сторінки (у наш час
  розмір сторінки дорівнює $1000), створить помилку доступу, навіть якщо захищена
  ділянка має довжину всього 1 байт, у результаті швидкість виконання програми
  дуже сильно впаде. Особливо, якщо частини коду розташовані на одній й тій же
  сторінці. Якщо програма залежить від швидкості виконання, те можлива різниця
  в виконанні. Таким чином, можливий варіант, що &nbsp; деякі програми не будуть
  працювати з захищеною пам'яттю. </p>

<h4>Приклад: контрольні суми по коду</h4>

<p>Якщо ви встановлюєте гру, використовуючи WHDLoad, ви
повинні виправити в грі процедури оригінальних
завантажників таким чином, щоб вони
використали WHDLoad, для завантаження дані ігри.
Деякі ігри виконують підрахунок контрольних
сум у деяких ділянках коду, щоб визначити,
чи не змінювався оригінальний код. Ці
підпрограми перевірки іноді дуже важко знайти.
Але використання функції <a href="../autodoc.html">resload_Protect
*?</a>&nbsp; в WHDLoad робить цей процес дуже простим.
Усе, що ви повинні зробити, це захистити від читання
ті байти, які ви змінили в коді гри. Тепер
кожна підпрограма, що спробує
підрахувати контрольну суму й прочитати ваш
виправлений код, створить помилку доступу. І ви зможете
довідаєтися де розташована ця підпрограма.</p>

<h4>Обмеження</h4>

<p>Ви не в якому випадку не повинні захищати ділянку
пам'яті, яку вказує SSP. Якщо ви все-таки це
зробили, то відбудеться Виключення, що приведе до
подвійній помилці шини (Double Bus Fault), тому що
центральний процесор не зможе записати stackframe
виключення. Після подвійної помилки шини має бути зроблене перезавантаження для продовження
роботи. WHDLoad перевіряє конфлікт захищеної
ділянки з SSP і закінчує усуваючи його, але це
не допомагає, якщо SSP змінюється пізніше.

<ul>
  <li>68020 + 68851 <ul>
      <li>така конфігурація в цей момент не
        підтримується </li>
    </ul>
  </li>
  <li>68030 <ul>
      <li>3-байтові передачі не підтримуються й створюють
        Помилку Доступу, такі передачі будуть виникати,
        якщо відбудеться звертання до &quot;довгого
        слова&quot; на непарній адресі на границі сторінки
        (наприклад, &quot;<code>tst.l ($fff)</code>&quot; де захищена
        сторінка, починаючи з адреси $1000). Оскільки це не
        стосується  процесорів 68000, то Ви швидше за все
        ніколи не зштовхнетеся з подібною ситуацією</li>
      <li>блоковані переміщення типу <strong><code>tas</code></strong>,
        <strong><code>cas </code></strong>або<strong><code> cas2</code></strong> не
        підтримуються й створять реальну Помилку
        Доступу, але це не є проблемою, тому що
        ці команди не підтримуються апаратними
        засобами Амігі. </li>
    </ul>
  </li>
  <li>68040 <ul>
      <li>така конфігурація в цей момент не
        підтримується </li>
    </ul>
  </li>
  <li>68060 <ul>
      <li>Доступ до невирівняних даних не
        підтримується й створить Помилку Доступу,
        невирівняний доступ - це доступ, що
        охоплює дві сторінки (і, у крайньому випадку, одна
        з них захищена), наприклад, &quot;<code>tst.l ($ffe)</code>&quot;
        стосується сторінки $0...$fff і сторінку $1000...$1fff,
        це обмеження - дійсно є проблемою і причиною того, що іноді неможливо
        використати функцію <strong>resload_Protect</strong>. Я
        спробую пізніше зробити підтримку цього, але це
        дуже важко. </li>
      <li>невирівняні доступи потоків інструкцій не
        підтримуються й створюють реальну Помилку
        Доступу, якщо обидві порушені сторінки захищені. В
        більшості випадків, таку ситуацію можна
        обійти</li>
      <li>блоковані переміщення, викликані <code>tas</code>
        або <code>cas</code> не підтримуються й створюють
        реальну Помилку Доступу, але це не є
        проблемою, тому що ці команди не
        підтримуються апаратними засобами Амігі.</li>
      <li>інструкції, які перебувають на захищеній сторінці (отже, що емулюються) і доступ до
        функцій supervisor'а регістра статусу, будуть
        виконані неправильно, ці інструкції будуть
        завжди бачити що <strong>trace bit</strong>&nbsp; виставлено в 1,
        а маска пріоритету переривання виставлена в 7,
        тому будь-яка зміна функцій supervisor'а не буде
        мати ніякого ефекту (тобто supervisor залишиться без
        змін). </li>
      <li><code>Інструкція <strong>movem</strong></code>&nbsp; може
        одержати доступ до захищеної ділянки, не
        створюючи виключення &quot;Помилка Доступу&quot;, це
        можливо, тому що тільки перше звертання
        (слово або довге слово) буде перевірене на
        відповідність захищеній ділянці. </li>
      <li><code>Інструкція <strong> move16</strong></code> й операцій з
        плаваючою комою (FPU) не підтримуються й
        створюють Помилку Доступу</li>
      <li>Команда &quot;<code>move (mem),(mem)</code>&quot; з
        адресами, створює джерела й
        призначення, що перекривають Помилку Доступу, тому що Misalignment
        буде виконуватися некоректно, наприклад &quot;<code>move.l
        ($ffc), ($ffe)</code>&quot;, де сторінка $1000...$1fff захищена й
        пам'ять перед виконанням містить ($ffc) =$11112222, ($1000)
        =$33334444, а після виконання, $1000 містить $11114444, а не
        $22224444.</li>
    </ul>
  </li>
</ul>
</body>
</html>
