<html>

<head>
<title>Snooping</title>
<meta name="DC.Language" content="ua">
<meta http-equiv="content-language" content="ua">
<meta http-equiv="content-type" content="text/html; charset=windows-1251">
<!-і $Id: snoop.html 1.4 2011/09/04 23:01:44 wepl Exp wepl $ -і>
</head>

<body>

<h3>Snooping (спостереження)</h3>

<h4>Що це таке</h4>

<p><strong>Snooping</strong> це особливість програми WHDLoad, що дозволяє спостерігати
  й вести журнал подій, доступів до регістрів <strong>Cia</strong> й <strong>Custom</strong>.
  Якщо активовано параметр <a href="opt.html#Snoop">Snoop</a>, то всі некоректні
  звернення створять Помилку Доступу, а встановлена програма буде завершена. WHDLoad надаст інформацію про причину помилки.
  
  <h4>Кастомні регістри</h4>Всі звернення про читання або запис до кастомних регістрів перевіряються.
  Помилкові звернення:
<ul>
  <li>доступи до заборонених регістрів </li>
  <li><em>читання</em> регістрів, призначених тільки
    для запису (Write Only)</li>
  <li><em>запис</em> у регістри, призначених тільки
    для читання (Read Only)</li>
  <li>доступ до регістрів Early Read</li>
  <li>спроба запису байта в регістри (за винятком <strong><tt>bltcon0l</tt></strong>
    і <strong><tt>aud*vol+1</tt></strong>) </li>
</ul>

<p>Регістри строба (Strobe) можуть бути прочитані або записані. Набір Custom-регістрів
  може змінюватися між OCS (Old ChipSet - A500, A1000, стара A2000), ECS (Enhanced
  ChipSet - A600, нова A2000, A3000) і AGA (Advanced Graphics - A1200, A4000).
  Це корисно для пошуку в старих програмах помилок через звертання до нових регістрів
  AGA.</p>

  
<h4>Cia регістри</h4>На Cia регістрах перевіряються лише записи даних.
Це означає, що звернення до неіснуючої регістрів у пам'яті 
$bfd000...$bfefff не буде виявлено. Для всіх запитів на запис, данні будуть збережені у WHDLoad. Для деяких регістрів Cia є спеціальні перевірки в залежності від значення:

<p><table border=1 summary="table of cia registers">
<tr>
	<th>адрес</th>
	<th>регістр</th>
	<th>перевірка</th>
</tr><tr>
	<td>$bfe001</td>
	<td>ciaa.ciapra</td>
	<td>налаштування Overlay біт #0 заборонено</td>
</tr><tr>
	<td>$bfe201</td>
	<td>ciaa.ciaddra</td>
	<td>біти #6-7 може мати будь-яке значення (використовується для джойстика), нижні біти повинні бути %000011</td>
</tr><tr>
	<td>$bfe801</td>
	<td>ciaa.ciatodlow</td>
	<td rowspan=3>доступ на читання-модифікація-запис (наприклад, bchg) не допускаються
якщо біт ALARM встановлено у ciaa.ciacrb (перевіряється тільки на 68060)</td>
</tr><tr>
	<td>$bfe901</td>
	<td>ciaa.ciatodmid</td>
</tr><tr>
	<td>$bfea01</td>
	<td>ciaa.ciatodhi</td>
</tr><tr>
	<td>$bfed01</td>
	<td>ciaa.ciaicr</td>
	<td>доступ на читання-модифікація-запис (наприклад, bchg) не допускаються (перевіряється тільки на 68060)</td>
</tr><tr>
	<td>$bfd100</td>
	<td>ciab.ciaprb</td>
	<td>біти для MOTOR #7, SELECT #3-6 і STEP #0 не повинні бути
очищанні, інші біти можуть бути змінені; але будь-який доступ до
флоппі дисків буде виявлен</td>
</tr><tr>
	<td>$bfd200</td>
	<td>ciab.ciaddra</td>
	<td>записанне значення повинно буди %11000000</td>
</tr><tr>
	<td>$bfd300</td>
	<td>ciab.ciaddrb</td>
	<td>записанне значення повинно буди %11111111</td>
</tr><tr>
	<td>$bfd800</td>
	<td>ciab.ciatodlow</td>
	<td rowspan=3>доступ на читання-модифікація-запис (наприклад, bchg) не допускаються
якщо біт ALARM встановлено у ciaa.ciacrb (перевіряється тільки на 68060)</td>
</tr><tr>
	<td>$bfd900</td>
	<td>ciab.ciatodmid</td>
</tr><tr>
	<td>$bfda00</td>
	<td>ciab.ciatodhi</td>
</tr><tr>
	<td>$bfdd00</td>
	<td>ciab.ciaicr</td>
	<td>доступ на читання-модифікація-запис (наприклад, bchg) не допускаються (перевіряється тільки на 68060)</td>
</tr></table>
  
<h4>Як це працює</h4>

<p>Якщо Snoop включений, WHDLoad помічає у списку перекладу диспетчера пам'яті
  (MMU) адреси Custom й Cia регістрів, як невірні/захищені від запису. Через це, кожний доступ до
  Custom або Cia регістрів закінчиться виключенням &quot;Помилка Доступу&quot;.
  Це виключення буде взято під управління WHDLoad. Спочатку, він перевіряє, чи
  дійсний доступ. Якщо доступ недійсний, програма буде завершена. Якщо доступ
  дійсний й якщо це операція читання, він буде емулюватися й виконання програми
  продовжиться. Якщо це операція запису то WHDload додатково, збереже значення
  у внутрішньому буфері. <br>
  Відбудеться вповільнення виконуваної програми, тому що будуть ще оброблятися
  виключення й буде проводитися емуляція. Наскільки уповільниться роботи програми,
  залежить від типу центрального процесора, типу Chip-пам'яті (16/32-bit) і вирівнювання
  покажчика стека, якщо Chip-пам'ять 32-х бітна (є вирівнювання по довгих словах
  або немає). Це також відрізняється для типу доступу (байт / слово / довге слово,
  читання/запис). 68030 пише, швидше ніж, читає (тому що читання, фрейму стека
  включає 92 байта, запис - 32 байта), на процесорах 68060 читання, швидше, тому
  що емуляція для запису, більше складна. </p>

<h4>Режим швидкого спостереження (Fast Snoop)</h4>

<p>Параметр <a href="opt.html#Snoop">Snoop/S</a> активізує режим швидкого спостереження.
  Доступи з читання перевірятися не будуть. Не буде проводитися ніяких спеціальних
  перевірок. Цей спосіб може бути корисний тільки для одержання змісту Custom-регістрів,
  наприклад, щоб зробити знімок екрана, використовуючи <a href="sp.html">SP</a>.</p>

<h4>Сканер Copper List'а</h4>

<p>Починаючи з версії 13, WHDLoad також може сканувати коперлісти (copperlists).
  Сканер буде активований на запис у регістри <strong><tt>coplc</tt></strong>,
  якщо активізовано copper dma, або коли встановлена програма активізує coppper
  dma, записуючи в регістр<strong><tt> dmacon</tt></strong>. Сканер стежить за
  коперлістом і підтверджує всі інструкції Move, застосовуючи обмеження, накладені
  опцією Snoop (OCS / ECS / AGA). Інструкції Skip й Wait (за виключенням CEND)
  будуть ігноруватися. Коли він знаходить недійсні входження, установлена програма
  завершується. Сканер також стежить за відгалуженнями (<tt>copjmp</tt>), виявляє
  цикли й перевіряє до 16 підперечнів. Інструкції Move у коперлістах будуть збережені
  у внутрішньому файлі регістрів, який буде створено WHDLoad при виході. Сканер
  не активний у режимі швидкого спостереження&nbsp; (Fast Snoop). </p>

<h4>Перевірка пріоритету блітера</h4>

<p>Коли активізована опція ChkBltHog/S, WHDLOAD
перевірить, що встановлена програма не активізує
біт BltHog, записуючи в <tt>dmacon</tt> регістр. Пріоритет
блітера може створити проблеми на деяких
апаратних конфігураціях при використанні всіх
його можливостей (при використанні всіх каналів).
</p>

<h4>Перевірка розміру блітера</h4>

<p>Коли параметр ChkBltSize/S активізований, WHDLOAD перевірить, щоб блітер не
  працював з пам'яттю за межами області BaseMem. При доступі на запис в <strong><tt>bltsize</tt>
  </strong>або <strong><tt>bltsizh</tt></strong>, він перевіряє, чи встановлений
  лінійний режим в <strong><tt>bltcon1</tt></strong>. Якщо лінійний режим активний,
  перевірка розміру буде скасована. Інакше WHDLoad визначить перше й останнє слово
  доступу до кожного активованого каналу прямого доступу до пам'яті. Якщо одна
  адреса перебуває за межами області пам'яті BaseMem, те програма буде завершена
  з висновком вікна повідомлення. Обчислення призначено для роботи з усіма режимами
  (ascending/descending, positive/negativ modulos, odd modulos/pointers). <br>
  Пом`ятайте, що режим &quot;line drawing&quot; не перевіряється й що всі регістри
  блітера можуть бути перезаписані копером, у випадку якщо встановлено <strong><tt>copcon</tt></strong>.
</p>

<h4>Перевірка очікування блітера (Blitter Wait Check)</h4>

<p>Коли параметр ChkBltWait/S активізований, WHDLOAD буде використовувати трасування
  інструкцій на предмет того, що встановлена програма дійсно правильно чекає закінчення
  роботи блітера, перед його наступним запуском. Whdload використає внутрішню
  змінну, котра відображає робочий стан блітерa. Змінна встановлюється, коли виконується
  запис в <tt>bltsize</tt> або <tt>bltsizh</tt>, і скидається, коли виконується
  читання з регістра <tt>dmaconr</tt>. При кожному записі в регістр блітера, перевіряється
  значення змінної, і якщо значення показує, що блітер запущено, то установлена
  програма буде завершена, а WHDLoad повідомить PC останньої запущеної задачі
  блітера разом з реальним доступом<br>
У даного параметра є два головних недоліки:<br>
1) використання блітера через копер НЕ перевіряється;<br>
  2) використання преривань блітера змусить процедуру перевірки виводити безглузді
  повідомлення про помилки</p>

<h4>Плани на майбутнє</h4>

<p>Планується реалізувати таку можливість, як
припинення програми й згортання її в іконку.
Для цього відмінно підходить <strong>Snoop</strong>. Тому,
для забезпечення сумісності надалі,
рекомендую авторам інсталяційних модулів
перевіряти коректність роботи ваших патчей з
параметром Snoop.</p>

<h4>Системні вимоги</h4>

<p>Для роботи параметра Snoop необхідний диспетчер пам'яті (MMU). WHDLoad також
  повинен <a href="mmu.html#usercontrol">використовувати</a> MMU, тому на машинах
  із процесорами 68030 необхідно активізувати опцію <a href="opt.html#MMU">MMU/S</a>.
</p>

<h4>Обмеження</h4>

<ul>
  <li>68020 + 68851 <ul>
      <li>Ця конфігурація в цей момент не
        підтримується</li>
    </ul>
  </li>
  <li>68030 <ul>
      <li>Невідомо ніяких обмежень </li>
    </ul>
  </li>
  <li>68040 <ul>
      <li>Ця конфігурація в цей момент не
        підтримується</li>
    </ul>
  </li>
  <li>68060 <ul>
      <li>Інструкція<tt> <strong>movem</strong></tt> може звернутися до недійсного
        регістра, не створивши при цьому повідомлення про помилку доступу. Це
        можливо тому, що тільки перше звернення буде оброблене на відповідність
        до данного регістра.</li>
      <li>Інструкція<tt> move &lt;Cia/Custom register&gt;,sr</tt>&nbsp; буде
        виконана неправильно, якщо вона змінює частину
        регістра статусу, що належить супервайзеру,
        частина супервайзера не зміниться. </li>
      <li>Кожна з команд <tt>(ssp)+</tt> або <tt>-(ssp)</tt> разом із доступом
        по записі в регістри Cia або Custom не може бути оброблена у зв'язку із
        проблемами фрейму стека. WHDLoad виявить таке звернення й завершить роботу
        програми з відповідної повідомленням</li>
      <li>Інструкції не повинні одночасно звертатися більш ніж до одного &quot;snooped&quot;-регістру.
        Це означає, що код, подібний move.b ($dff006), ($bfd800) не може бути
        оброблений й якщо такий код буде виконано, то WHDLOAD виведе повідомлення
        про помилку доступу.</li>
    </ul>
  </li>
</ul>
</body>
</html>
