<HTML>
<HEAD>
<TITLE>Το WHDLoad και η MMU</TITLE>
<meta name="DC.Language" content="gr">
<meta http-equiv="content-language" content="gr">
<meta http-equiv="content-type" content="text/html; charset=iso-8859-7">
<!-- $Id: mmu.html 1.4 2015/04/19 21:08:08 wepl Exp wepl $ -->
</HEAD>
<BODY>
<h3>Το WHDLoad και η Memory Management Unit (MMU)</h3>
Μια MMU περιέχεται στους ακόλουθους επεξεργαστές της οικογένειας 68000: 68030,
68040, 68060. Υπάρχουν επίσης και οι λεγόμενες EC εκδόσεις αυτών των επεξεργαστών
που έχουν ένα χαλασμένο, εκτός λειτουργίας MMU. Για παράδειγμα, όλες οι τυπικές A4000/030
έχουν μόνο έναν 68EC030 CPU. Σε επιταχυντές τρίτων αυτό είναι διαφορετικό,
δείτε στις κατάλληλες οδηγίες για να μάθετε περισσότερα. Από όσο
γνωρίζω, όλοι οι 68040/68060 που μπήκαν ποτέ σε Amiga είναι πλήρης CPU και
περιέχουν ένα λειτουργικό MMU. Αυτό διότι η Zorro III απαιτεί απεικόνιση της MMU του χώρου Ι/Ο.
Η διάκριση μεταξύ μιας πλήρης CPU και μιας έκδοσης EC δεν μπορεί να γίνει μέσω λογισμικού.
Συνεπώς ο χρήστης πρέπει να το κάνει αυτό
ορίζοντας τις <a href="#usercontrol">κατάλληλες επιλογές</a> για το WHDLoad.
<br>Για τον 68020 υπάρχει μια εξωτερική MMU που ονομάζεται 68851, αλλά αυτό
προς το παρόν δεν υποστηρίζεται από το WHDload.
<h4>Χαρακτηριστικά μιας MMU και η χρήση της στο WHDLoad</h4>
Ο κύριος σκοπός της MMU είναι να μεταφράζει λογικές διευθύνσεις σε φυσικές
διευθύνσεις. Αυτό απαιτείται για εικονική μνήμη και ξεχωριστούς χώρους διευθύνσεων.
Ένα άλλο χαρακτηριστικό είναι ο ορισμός
ειδικών ιδιοτήτων όπως Supervisor Only, Write Protected και λειτουργία Caching για
κάθε φυσικό χώρο διεύθυνσης, ρυθμισμένη με βάση σελίδας, όπου η σελίδα που χρησιμοποιείται
στο WHDLoad έχει μέγεθος 4096 bytes. Το WHDLoad δεν χρησιμοποιεί μετάφραση λογικής σε φυσική
διεύθυνση. Αλλά χρησιμοποιεί την MMU για <a href="#mem">προστασία μνήμης</a>, <a
href="cache.html">διαχείριση προσωρινής μνήμης - cache</a> και μερικά ειδικά χαρακτηριστικά  (<a
href="snoop.html">Παρατήρησης (Snooping)</a>, <A
HREF="../autodoc.html">resload_Protect#?</a>).
<h4><a name="mem">Προστασία μνήμης στο WHDLoad</a></h4>
Στην εκκίνηση, το WHDLoad σαρώνει τη λίστα μνήμης και δημιουργεί ένα δέντρο μετάφρασης
που συμπεριλαμβάνει όλη τη προσβάσιμη μνήμη. Σημειώνει τους ακόλουθους χώρους διευθύνσεων ως
έγκυρους και προσβάσιμους: $0...BaseMem (χρησιμοποιώντας τις πληροφορίες από το Slave),
$dff000...$dff200 (ειδικοί καταχωρητές), $bfd000...$bff000 (καταχωρητές CIA) και
τη μνήμη που χρησιμοποιείται από το Slave και το WHDLoad. Εάν βρεθεί πάγωμα στη μνήμη, η
μνήμη που χρησιμοποιείται από το πρόγραμμα παγώματος θα σημειωθεί επίσης ως έγκυρη. Όλη η υπόλοιπη μνήμη
σημειώνεται ως άκυρη, και συνεπώς κάθε πρόσβαση σε τέτοια περιοχή (Read ή Write)
θα δημιουργήσει μια εξαίρεση Access Fault Exception που θα τερματίσει με ένα κατάλληλο
επιλογέα σφάλματος που θα δημιουργηθεί από το WHDLoad.
<h4><a name="usercontrol">Έλεγχος χρήστη του χειρισμού της MMU στο WHDLoad</a></h4>
Υπάρχουν 3 διαφορετικές λειτουργίες για το πως το WHDLoad επηρρεάζει μια MMU.
<ol>
<li><b>παράβλεψη MMU</b>:<br>
Σε αυτή την κατάσταση το WHDLoad δεν αλλάζει κανένα καταχωρητή που σχετίζεται με την MMU.
Αυτό μπορεί να είναι χρήσιμο αν έχετε προγράμματα που χτυπούν την MMU να τρέχουν και θέλετε
οι λειτουργίες αυτών των προγραμμάτων να παραμείνουν άθικτες (για παράδειγμα ένα
πρόγραμμα παγώματος όπως το TK).
<br>
Προειδοποίηση: Επειδή το WHDLoad δεν ελέγχει την MMU μόνο του είναι πιθανά
πολλά προβλήματα. Αυτά τα προβλήματα μπορεί να προκαλέσουν δυσλειτουργίες, ή άλλες
απρόβλεπτες συμπεριφορές. Παρακάτω είναι μια λίστα υπαρκτών ρίσκων:
<ul>
<li>τρέχοντας τα Enforcer/CyberGuard ή αντίστοιχα εργαλεία θα παγώσει/παρουσιάσει κατάρρευση το μηχάνημα,
γιατί το WHDLoad θα δημιουργήσει πολλά χτυπήματα κάθε φορά που απενεργοποιεί και ενεργοποιεί το λειτουργικό.
Αυτά τα χτυπήματα δεν είναι σφάλματα του WHDLoad αλλά μέρος της κανονικής του λειτουργίας.
<li>νεότερες εκδόσεις της 68060.library (ξεκινώντας με τη v41.1) θα προωθήσουν τη μνήμη
$0-$1000 (τη πρώτη σελίδα) σε μια περιοχή μνήμης της Fast χρησιμοποιώντας την MMU, στην κατάσταση "παράβλεψη
MMU" αυτή η μετάφραση μνήμης θα παραμείνη άθικτη, αν το εγκατεστημένο πρόγραμμα
προσπαθήσει να χρησιμοποιήσει αυτή τη περιοχή για λειτουργίες DMA (π.χ. ένα copperlist σε αυτή
τη περιοχή) τα αποτελέσματα θα είναι απρόβλεπτα, γιατί η CPU θα διαβάσει/γράψει στη περιοχή
μνήμης της Fast ενώ τα DMA στην πραγματική μνήμη Chip που περιέχει
τυχαία δεδομένα.
<li>αν τα τρέχοντα πράγματα του MMU χρησιμοποιούν μνήμη (χειριστής εξαιρέσεων, δέντρο
μετάφρασης κτλ) μέσα στη BaseMem του εγκατεστημένου προγράμματος, μπορεί να αποτύχει, γιατί η
BaseMem θα επανεγγραφεί κατά τη διάρκεια εκτέλεσης του εγκατεστημένου προγράμματος.
<li>γενικά κάθε πρόγραμμα που αλλάζει βασικές λειτουργίες του συστήματος (χρησιμοποιώντας
την MMU) μπορεί να συγκρουστεί με το WHDLoad...
</ul>
<li><b>απενεργοποίηση MMU</b>:<br>
Σε αυτή τη κατάσταση, που είναι δυνατή μόνο σε 68030, η MMU θα απενεργοποιηθεί από το
WHDLoad, κανένα χαρακτηριστικό σχετικό με την MMU δεν θα είναι διαθέσιμο.
<li><b>χρήση MMU</b>:<br>
Σε αυτή τη κατάσταση το WHDLoad παίρνει το πλήρη έλεγχο της MMU και πραγματοποιεί
προστασία μνήμης και διαχείριση προσωρινής μνήμης (cache) όπως εξηγείται παραπάνω.
</ol>
Στον 68030 η προεπιλεγμένη κατάσταση είναι <i>απενεργοποίηση MMU</i>. Στον 68040/68060 η προεπιλογή είναι <i>χρήση MMU</i>. Υπάρχουν δύο επιλογές για τον έλεγχο αυτής της συμπεριφοράς. <a href="http://www.whdload.de/docs/en/opt.html#MMU">MMU/S</a> αναγκάζει το WHDLoad να <i>χρησιμοποιήσει</i> την <i>MMU</i> και απαιτείται σε συστήματα με 68030 για να ενεργοποιηθούν όλα τα χαρακτηριστικά της MMU. <a href="http://www.whdload.de/docs/en/opt.html#NoMMU">NoMMU/S</a> απενεργοποιεί τη χρήση της MMU από το WHDLoad (<i>παράβλεψη MMU</i>).
<center><p><cite>Ένα χτύπημα Enforcer είναι ένα χτύπημα Enforcer, τέλος.</cite> (Michael Sinz)</p></center>
</BODY>
</HTML>
