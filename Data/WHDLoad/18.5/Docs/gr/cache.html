<HTML>
<HEAD>
<TITLE>Χειρισμός CPU Cache</TITLE>
<meta name="DC.Language" content="gr">
<meta http-equiv="content-language" content="gr">
<meta http-equiv="content-type" content="text/html; charset=iso-8859-7">
<!-- $Id: cache.html 1.6 2015/04/19 21:08:08 wepl Exp wepl $ -->
</HEAD>
<BODY>
<h3>Γενικά για CPU Cache</h3>
Για να βελτιώσουν την απόδοσή τους μερικοί από τους επεξεργαστές της οικογένειας 68k
μπορούν να κρατάνε στην cache διευθύνσεις μνήμης.
<br>Στα Caches αναφερόμαστε παντα με λογικές διευθύνσεις, συμπεριλαμβανομένου του
κώδικα συνάρτησης της πρόσβασης. Αυτό σημαίνει ότι η πρόσβαση σε User Mode και
Supervisor Mode θα δημιουργήσει διαφορετικές καταχωρήσεις Cache (παρακαλώ συμβουλευτείτε τα εγχειρίδια της Motorola
για περισσότερες πληροφορίες).

<p>Ακολουθεί μια περιγραφή των δυνατοτήτων caching στους 68k CPU:
<ul><li>68000
τίποτα

<li>68010<ul>
<li>Instruction Prefetch
<br>δύο words prefetch, ένας καταχωρητής αποκωδικοποίησης word
<li>Loop Mode
<br>εδώ μπαίνει όταν μια εντολή word ακολουθείται από ένα loop DBcc στην προηγούμενη
εντολή, και δεν γίνονται άλλες λήψεις εντολών μέχρι το τέλος του loop

</ul><li>68020<ul>
<li>Instruction Prefetch
<br>μία long word
<li>Instruction Cache
<br>16 γραμμές &aacute; 16 byte = 256 byte
<br>μπορεί να ενεργοποιηθεί ή να παγώσει μέσω του CACR
<br>Η λειτουργία Burst εξαναγκάζει όλες τις γραμμές cache να αναγνωστούν αμέσως αν το υποστηρίζει το hardware

</ul><li>68030<ul>
<li>Instruction Prefetch
<br>μία long word
<li>Instruction Cache
<br>16 γραμμές &aacute; 16 byte = 256 byte
<br>μπορεί να ενεργοποιηθεί ή να παγώσει μέσω του CACR
<li>Data Cache
<br>16 γραμμές &aacute; 16 byte = 256 byte
<br>μπορεί να ενεργοποιηθεί ή να παγώσει μέσω του CACR
<br>πάντα WriteThrough
<br>επιλεγόμενη λειτουργία Write Allocation για εξαναγκασμό εγγραφής λειτουργιών άλλων
καταχωρήσεων user/supervisor ώστε να ακυρωθούν

</ul><li>68040<ul>
<li>Instruction Prefetch
<br>μία long word
<li>Instruction Cache
<br>256 γραμμές &aacute; 16 byte = 4096 byte
<br>μπορεί να ενεργοποιηθεί μέσω του CACR
<li>Data Cache
<br>256 γραμμές &aacute; 16 byte = 4096 byte
<br>μπορεί να ενεργοποιηθεί μέσω του CACR
<br>επιλεγόμενες λειτουργίες CopyBack/WriteThrough μέσω MMU

</ul><li>68060<ul>
<li>Instruction Prefetch
<br>μία long word
<li>Instruction Cache
<br>512 γραμμές &aacute; 16 byte = 8192 byte
<br>μπορεί να ενεργοποιηθεί, να παγώσει και να μειωθεί στο μισό μέγεθος μέσω του CACR
<li>Branch Cache
<br>μπορεί να ενεργοποιηθεί μέσω του CACR
<br>δεν επηρρεάζεται από την ρύθμιση MMU!
<li>Superscalar Dispatch
<br>μπορεί να ενεργοποιηθεί μέσω του CACR
<li>Data Cache
<br>512 γραμμές &aacute; 16 byte = 8192 byte
<br>μπορεί να ενεργοποιηθεί, να παγώσει και να μειωθεί στο μισό μέγεθος μέσω του CACR
<br>επιλεγόμενες λειτουργίες CopyBack/WriteThrough μέσω MMU
<li>Push Buffer
<br>μπορεί να απενεργοποιηθεί μέσω του PCR
<li>Store Buffer
<br>μπορεί να ενεργοποιηθεί μέσω του CACR
<br>Οι σελίδες δεν πρέπει να είναι NonCachable Serialized (ακριβώς)
</ul></ul>

<h4><a name="cache">Διαχείριση Cache στο WHDLoad</a></h4>
Το πιο σημαντικό πράγμα που πρέπει να κατανοηθεί είναι ότι τα caches στους 68030..68060
ελέγχονται από τον Cache Control Register (CACR) <b>και</b> η MMU!
<br>Στον CACR τα caches θα είναι καθολικά ενεργοποιημένα ή απενεργοποιημένα. Με τη χρήση της
MMU μεμονωμένες Σελίδες (των 4 KByte με το WHDLoad) θα σημειωθούν πως μπορούν να είναι cached.
<br>Στον 68030 μία σελίδα μνήμης μπορεί να είναι Cacheable ή NotCacheable. Σε έναν
68040/68060 μπορεί να είναι cachable WriteThrough, cachable CopyBack, NonCachable
(ασαφώς) ή NonCachable Serialized (ακριβώς).
<p>Εάν το MMU δεν χρησιμοποιηθεί από το WHDLoad, τότε ελέγχει μόνο τον CACR.

<h4>Προεπιλεγμένες Ρυθμίσεις Cache</h4>
Από προεπιλογή οι περιοχές του WHDLoad, του Slave και ExpMem σημειώνονται ως
cacheable CopyBack. Η περιοχή BaseMem σημειώνεται ως NonCachable, και τα Data
και Instruction Cache ενεργοποιούνται στον CACR. Οπότε το πρόγραμμα που βρίσκεται
στην περιοχή BaseMem τρέχει χωρίς Caches αλλά το WHDLoad, το Slave και η ExpMem χρησιμοποιούν
τα Caches για καλύτερη απόδοση. Εάν η MMU δεν χρησιμοποιείται από το WHDLoad αυτή η ρύθμιση
έχει ως αποτέλεσμα να απενεργοποιηθούν όλα τα Caches γιατί χωρίς την MMU δεν είναι δυνατό να ρυθμιστούν
διαφορετικά ξεχωριστές περιοχές μνήμης, οπότε εάν κάποια περιοχή έχει οριστεί ως NonCacheable τότε
όλα τα Caches πρέπει να απενεργοποιηθούν.

<h4>Έλεγχος Cache για Προγραμματιστές</h4>
Υπάρχουν δύο συναρτήσεις resload που ελέγχουν τα Caches: <a HREF="../autodoc.html#resload_SetCACR">resload_SetCACR</a> 
και <a HREF="../autodoc.html#resload_SetCPU">resload_SetCPU</a>. Η <a href="../autodoc.html#resload_SetCACR">resload_SetCACR</a> είναι η
ιστορικά παλιότερη ρουτίνα και μπορεί να αντικατασταθεί πλήρως από την <a href="../autodoc.html#resload_SetCPU">resload_SetCPU</a> (Το WHDLoad
εσωτερικά κρατάει τις παραμέτρους της <a href="../autodoc.html#resload_SetCACR">resload_SetCACR</a> και καλεί την <a href="../autodoc.html#resload_SetCPU">resload_SetCPU</a>).
Τελικά η χρήση της <a href="../autodoc.html#resload_SetCACR">resload_SetCACR</a> συνιστάται για όλους τους ανθρώπους που δεν ξέρουν
αρκετά για τα Caches και τη συμπεριφορά τους σε ένα σύστημα Amiga. Χρησιμοποιώντας
την <a href="../autodoc.html#resload_SetCACR">resload_SetCACR</a> τα instruction και data cache μπορούν ανεξάρτητα να ενεργοποιηθούν ή
να απενεργοποιηθούν. Η <a href="../autodoc.html#resload_SetCACR">resload_SetCACR</a> επηρρεάζει μόνο τη δυνατότητα cache της περιοχής BaseMem.

<h4>Έλεγχος Cache για Χρήστες</h4>
Αν ο προγραμματιστής έχει κάνει καλά τη δουλειά του τότε ο χρήστης δεν έχει τίποτα να κάνει
σχετικά με τα Caches γιατί όλες οι απαραίτητες ρυθμίσεις έχουν ήδη γίνει από το
Slave.
<br>Ωστόσο ίσως υπάρχουν δύο λόγοι για να αλλάξει χειροκίνητα η ρύθμιση Cache.
Πρώτον να κάνετε μια εγκατάσταση να δουλέψει σωστά γιατί έχει πρόβλημα επειδή τρέχει πολύ
γρήγορα (π.χ. δημιουργεί παράσιτα στα γραφικά) και δεύτερον για να κάνετε ένα εγκατεστημένο
πρόγραμμα πιο γρήγορο.
<p>Για να κάνετε ένα πρόγραμμα που δεν λειτουργεί να λειτουργήσει, η επιλογή 
	<a href="opt.html#NoCache">NoCache</a> μπορεί να χρησιμοποιηθεί. Αυτή η επιλογή
απενεργοποιεί όλα τα τα caches και σημειώνει όλη τη μνήμη ως NonCachable Serialized (ακριβώς). Αν το μηχάνημα
έχει 32-bit Chip-Memory θα συνεχίσει να είναι γρηγορότερο από μία αυθεντική A500.
<p>Για να κάνετε ένα εγκατεστημένο πρόγραμμα γρηγορότερο μπορούν να οριστούν μερικές επιλογές που θα ενεργοποιήσουν
τα Caches. Αυτό θα αντικαταστήσει τις ρυθμίσεις του Slave. Σε έναν 68020 η επιλογή
<a href="opt.html#Cache">Cache</a> μπορεί να οριστεί. Σε 68030 επίσης η επιλογή 
<a href="opt.html#DCache">DCache</a> μπορεί να οριστεί που συμπεριλαμβάνει την επιλογή Cache.
Στον 68060 υπάρχουν περισσότερες επιλογές: <a href="opt.html#BranchCache">BranchCache</a>,
<a href="opt.html#StoreBuffer">StoreBuffer</a> και
<a href="opt.html#SuperScalar">SuperScalar</a>. Η επιλογή 
<a href="opt.html#ChipNoCache">ChipNoCache/S</a> μπορεί να βελτιώσει την απόδοση
σε 68040 και 68060, δείτε παρακάτω.

<a name="chipmem"></a><h4>Δυνατότητα Cache της Μνήμης Chip</h4>
Η δυνατότητα cache μπορεί να οριστεί όχι μόνο για τον ίδιο τον επεξεργαστή (CACR) και τις ρυθμίσεις της MMU, 
αλλά επίσης και για εξωτερικό hardware. Ο CPU δίνει σήμα στο bus αν προσπαθεί να
βάλει στην cache μια πρόσβαση. Και το εξωτερικό hardware μπορεί να στείλει σήμα στον CPU (μετά από
τοποθέτηση μιας διεύθυνσης στο address bus κατά τη διάρκεια πρόσβασης μνήμης) ότι κάποια
πρόσβαση δεν πρέπει να μπεί στην cache.
<br>Ο μηχανισμός που το hardware στέλνει σήμα στην CPU ότι η μνήμη πρέπει ή δεν πρέπει
να μπει στη cache χρησιμοποιείται σε όλες τις (όσο ξέρω) Amiga και τα CPU-Boards που περιέχουν
CPU &gt;= 68030 (επειδή έχουν data cache). Επηρρεαζόμενες είναι όλη η
Chip-Memory και το IO-Space (Cia/Custom/RTC) που δεν πρέπει να μπουν στη cache
από το data cache. Αυτό είναι απαραίτητο για να αποφευχθούν ασυμφωνίες της cache, για
παράδειγμα λόγω δραστηριότητας DMA.
<br>Η αντίδραση του CPU σε μια άρνηση από hardware για τοποθέτηση πρόσβασης στην cache
διαφέρει σε διαφορετικούς CPU. Στον 68030 δεν υπάρχει επίπτωση στην απόδοση της
πρόσβασης, τα δεδομένα απλά δεν θα μπούν στη cache. Στον 68040 οι προσβάσεις ανάγνωσης θα γίνουν
σε πλήρη ταχύτητα αλλά οι προσβάσεις εγγραφής (CopyBack) θα
ακυρωθούν και θα ξεκινήσουν πάλι χωρίς να μπαίνουν στη cache
με αποτέλεσμα περίπου 5 φορές (εξαρτάται από το
hardware και την ταχύτητα της CPU) αργότερη πρόσβαση σε σύγκριση
με μία πρόσβαση χωρίς cache. Στον 68060 οι προσβάσεις ανάγνωσης και εγγραφής θα ακυρωθούν
και θα ξεκινήσουν πάλι. Οι προσβάσεις ανάγνωσης
θα είναι περίπου 3 φορές αργότερες και οι προσβάσεις εγγραφής θα είναι περίπου 5 φορές αργότερες.
<br>Τα αναφερόμενα θέματα σχετίζονται με προσβάσεις δεδομένων. Οι προσβάσεις εντολών συνήθως
δεν επηρρεάζονται και είναι cacheable μέσα στην Chip-Memory.
Υπάρχει κάποιο (ίσως προβληματικό) hardware που δεν επιτρέπει εντολές να
μπαίνουν στη cache από την Chip-Memory. Σε τέτοιο hardware η επιλογή <a
href="opt.html#ChipNoCache">ChipNoCache/S</a> πρέπει να χρησιμοποιηθεί για να
αποφευχθεί μεγάλη καθυστέρηση στην ταχύτητα εκτέλεσης γιατί διαφορετικά οι προσβάσεις εντολών θα είναι
περίπου 2 φορές αργότερες.
<br>Αυτή η συμπεριφορά μπορεί να ελεχθεί εκτελώντας την <i>Speed.Slave</i>
που περιέχεται στον κατάλογο <tt>src/memory-speed</tt> του αρχείου προγραμματιστών.

<h4>Burst Mode</h4> Η λειτουργία Burst στον 68030 αναφέρει στην CPU να διαβάσει πάντα μια
γεμάτη γραμμή cache (16 bytes), εάν προκύψει μια έλλειψη cache αντί για μια μόνο long word
που ζητήθηκε. Η λειτουργία Burst θα πρέπει να υποστηρίζεται από το hardware, αν όχι τότε
δεν γίνεται κάποιο Burst χωρίς κάποια ποινή στον συγχρονισμό. Η λειτουργία Burst μπορεί
να ενεργοποιηθεί ξεχωριστά για την instruction και data cache. Επειδή η πρόσβαση Burst
χρειάζεται περισσότερο χρόνο από μια απλή πρόσβαση, η λειτουργία Burst δίνει μόνο ένα
πλεονέκτημα επίδοσης, εάν οι περισσότερες από της καταχωρήσεις στην γραμμή cache έχουν
χρησιμοποιηθεί πριν καθαριστούν οι γραμμές cache. Για την instructions cache η λειτουργία
Burst συνήθως βελτιώνει την επίδοση. Για την data cache, συχνά μόνο σε σενάρια όπου γίνονται
συνεχείς αναγνώσεις μνήμης. Το WHDLoad ενεργοποιεί την instruction Burst μαζί με την instruction
cache, ξεκινώντας από την έκδοση 18.0. Η data Burst δεν θα ενεργοποιηθεί από το WHDLoad.

<h4>Write Allocation</h4>
Η Write Allocation ελέγχει το χειρισμό της cache στον 68030 όταν συμβαίνει αστοχία cache
σε μια διαδικασία εγγραφής. Η Write Allocation πρέπει να είναι ενεργοποιημένη όταν μέρη του
εγκατεστημένου προγράμματος τρέχουν σε User Mode. Αν το εγκατεστημένο πρόγραμμα τρέχει μόνο σε
Supervisor Mode, η Write Allocation μπορεί να απενεργοποιηθεί, όπου μπορεί να δώσει ένα μικρό
βοήθημα απόδοσης.

<h4>Branch Cache</h4>
<p>Η Branch Cache είναι διαθέσιμη μόνο σε 68060. Είναι ένα είδος
cache εντολών για εντολές branch. Αλλά σε αντίθεση με την
cache εντολών δεν επηρρεάζεται από τις ρυθμίσεις της MMU! Αυτό σημαίνει ότι ακόμα και όταν
η κατάλληλη σελίδα μνήμης έχει σημειωθεί ως Non Cacheable, οι εντολές branch
θα είναι cached εάν η Branch Cache είναι ενεργοποιημένη.</p>
<hr>Διαβάστε τα Motorola Microprocessors User Manuals για περισσότερες πληροφορίες.
Εάν έχετε κάτι να προσθέσετε ή να διορθώσετε σε αυτή τη σελίδα παρακαλώ <A
HREF="mailto:wepl@whdload.de">επικοινωνήστε</A> μαζί μου.
</BODY>
</HTML>
