<HTML>
<HEAD>
<TITLE>Προγραμματίζοντας το WHDLoad</TITLE>
<meta name="DC.Language" content="gr">
<meta http-equiv="content-language" content="gr">
<meta http-equiv="content-type" content="text/html; charset=iso-8859-7">
<!-- $Id: howto.html 1.3 2015/04/19 21:08:08 wepl Exp wepl $ -->
</HEAD>
<BODY>
<h3>Σχηματική ροή εκτέλεσης</h3>
<p>Ο ακόλουθος πίνακας δείχνει την ροή προγράμματος όταν θα εκτελεστεί μια εγκατάσταση
του WHDLoad. Ελπίζω να σας βοηθήσει να καταλάβετε πως δουλεύει το WHDLoad και πως το
WHDLoad, το Slave και το εγκατεστημένο πρόγραμμα συνεργάζονται.</p>
<table cellpadding=3>
  <tr>
    <td valign=top>Ο ΧΡΗΣΤΗΣ</td>
    <td>
      <ul>
        <li>ξεκινάει το demo ή παιχνίδι κάνοντας κλικ στο εικονίδιο ή ξεκινώντας
            το WHDLoad από τη γραμμή εντολών
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>Το Λειτουργικό Σύστημα</td>
    <td valign=top>
      <ul>
        <li>φορτώνει το εκτελέσιμο αρχείο του WHDLoad και το ξεκινάει
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>Το WHDLoad</td>
    <td>
      <ul>
        <li>ελέγχει το περιβάλλον Software και Hardware
        <li>φορτώνει και ελέγχει το Slave
        <li>κατανέμει την απαιτούμενη μνήμη για το εγκατεστημένο πρόγραμμα
        <li>εάν η <a href="opt.html#Preload">Preload/S</a>έχει ενεργοποιηθεί φορτώνει
            τους εικονικούς δίσκους και τα αρχεία στην RAM (εφόσον υπάρχει διαθέσιμη
            ελεύθερη μνήμη)
        <li>κλείνει το OS (απενεργοποιεί το mutitasking και τα interrupts, υποβαθμίζει
            το hardware γραφικών σε OCS, ξεκινά όλο το hardware με ορισμένες τιμές)
        <li>μεταπηδάει στο Slave
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>Slave</td>
    <td>
      <ul>
        <li>φορτώνει το κυρίως εκτελέσιμο αρχείο του εγκατεστημένου προγράμματος καλώντας μια συνάρτηση του
            WHDLoad (π.χ. <a
            href="../autodoc.html#resload_DiskLoad">resload_DiskLoad</a> ή <a
            href="../autodoc.html#resload_LoadFile">resload_LoadFile</a>)
        <li>διορθώνει το κυρίως εκτελέσιμο αρχείο (ότι το πρόγραμμα θα φορτώσει τα δεδομένα του
            μέσω του Slave, να διορθώσει προβλήματα συμβατότητας, να ενεργοποιήσει μια έξοδο
            από το πρόγραμμα)
        <li>καλεί το κυρίως εκτελέσιμο αρχείο
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>Εγκατεστημένο πρόγραμμα</td>
    <td>
      <ul>
        <li>θα κάνει τα πράγματά του
        <li>στο φόρτωμα δεδομένων από τον δίσκο θα καλέσει το Slave (επειδή το
            Slave το έχει διορθώσει έτσι προηγουμένως), και το Slave
            θα καλέσει το WHDLoad, και το WHDLoad θα ενεργοποιήσει μερικώς το OS για να
            φορτώσει τα δεδομένα (μόνο αν τα δεδομένα δεν είναι ήδη με <a
            href="opt.html#Preload">Preload</a>), μετά επιστρέφει
            και το εγκατεστημένο πρόγραμμα συνεχίζει
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>Ο ΧΡΗΣΤΗΣ</td>
    <td>
      <ul>
        <li>βγαίνει από το πρόγραμμα πατώντας το <a
            href="opt.html#QuitKey">QuitKey</a>
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>το Slave</td>
    <td>
      <ul>
        <li>επιστρέφει στο WHDLoad καλώντας την <a
            href="../autodoc.html#resload_Abort">resload_Abort</a>
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>το WHDLoad</td>
    <td>
      <ul>
        <li>επανενεργοποιεί το OS (επαναφέρει τους καταχωρητές hardware, την οθόνη και τη μνήμη)
        <li>απελευθερώνει όλους τους κατανεμημένους πόρους
        <li>και επιστρέφει στο OS
      </ul>
    </td>
  </tr>
</table>
<h3>Πως να εγκαταστήσετε έναν απλό trackloader μιας δισκέτας</h3>
Αυτός είναι ένα πολύ μικρός και σύντομος οδηγός βήμα-βήμα για το πως να δημιουργήσετε μια εγκατάσταση για ένα demo/παιχνίδι NDOS
χρησιμοποιώντας το WHDLoad. Ο οδηγός αντιπροσωπεύει μια ιδανική απλή περίπτωση. Στον πραγματικό κόσμο
μια τέτοια περίπτωση μάλλον δεν θα υπάρξει ποτέ. Για ειδικές περιπτώσεις και προβλήματα, διαβάστε τα κεφάλαια
που ακολουθούν.
<ol>
  <li>Προεργασία
    <ul>
      <li>Δημιουργήστε έναν κατάλογο που θα κρατήσει όλα τα αρχεία.
      <li>Δημιουργήστε έναν εικονικό δίσκο χρησιμοποιώντας το <A HREF="dic.html"> DIC </A> σε
          αυτόν το κατάλογο.
      <li>Δημιουργήστε ένα αρχείο <a href="opt.html#optwb">#?.info</a> με το "WHDLoad"
          ως &lt;Default Tool&gt; και έναν τύπο εργαλείων "SLAVE=#?" που περιέχει το
          όνομα του slave (ή απλά αντιγράψτε το εικονίδιο από ένα Παράδειγμα
          Εγκατάστασης, και απενεργοποιήστε όλους τους τύπους εργαλείων εκτός του "SLAVE=").
    </ul>
  <li>Το Slave<br>
    Για την εγγραφή του slave χρειαζόμαστε τις παρακάτω πληροφορίες:
    <ol>
      <li>Που στο δίσκο βρίσκεται το κυρίως εκτελέσιμο αρχείο;
      <li>Που μέσα στο κυρίως εκτελέσιμο αρχείο βρίσκεται ο disk loader;
    </ol>
    Για να πάρουμε αυτές τις πληροφορίες πρώτα αναλύουμε το bootblock. Τις περισσότερες φορές
    το κυρίως εκτελέσιμο αρχείο θα φορτωθεί από εδώ μέσω της exec.DoIO(). Μερικές φορές
    ένας ειδικός trackloader μπορεί να βρίσκεται στο bootblock. Τώρα γράφουμε ένα Slave που
    θα εξομοιώσει το bootblock και θα φορτώσει το κυρίως εκτελέσιμο αρχείο από τον εικονικό
    δίσκο. Τώρα εξάγουμε το κυρίως εκτελέσιμο αρχείο από την εικόνα ή από μια <a
    href="dump.html#memory">ένδειξη μνήμης</a>. Μετά από αυτό
    πρέπει να βρούμε τον loader στο κυρίως εκτελέσιμο αρχείο. Ένας γρήγορος τρόπος είναι να ψάξουμε για το μοτίβο
    <tt>$AAAAAAAA</tt> (χρησιμοποιείται από την αποκωδικοποίηση MFM) με έναν επεξεργαστή hex. Μετά αποκόβουμε την περιοχή
    (+/- <tt>$1000</tt> bytes) που βρήκαμε, την κάνουμε disassemble, και ψάχνουμε για την αρχή της
    ρουτίνας. Καταννοούμε τη λίστα παραμέτρων. Τώρα χρησιμοποιούμε κώδικα για το Slave
    που θα διορθώσει αυτή τη ρουτίνα του loader με τέτοιο τρόπο που όλες οι κλήσεις στο
    loader θα προωθούνται στο Slave. Το Slave τότε θα προσαρμόσει τις
    παραμέτρους και θα καλέσει τη συνάρτηση του WHDLoad <a
    href="../autodoc.html#resload_DiskLoad">resload_DiskLoad</a>.
  <li>Στην ιδανική περίπτωση η εγκατάσταση είναι τώρα ολοκληρωμένη.<br>
Ένα πράγμα που απομένει είναι να δημιουργήσουμε ένα ωραίο Εικονίδιο. Εξάγετε δύο εικόνες χρησιμοποιώντας το
<a href="snoop.html">χαρακτηριστικό snoop</a> του WHDLoad και το <a href="sp.html">SP</a>
ή ένα πρόγραμμα παγώματος ή το UAE για να κάνετε εξαγωγή εικόνων και να φτιάξετε το εικονίδιο. Προτείνεται η παλέτα 16 χρωμάτων του <a
href="ftp://ftp.wustl.edu/pub/aminet/pix/mwb/RomIcons10.lha">RomIcon</a>.
</ol>
<h3>Πιθανά προβλήματα και ειδικές περιπτώσεις</h3>
<h4>Μη κανονικός trackloader</h4>
Μερικά προγράμματα χρησιμοποιούν δική τους μορφή δίσκου (disk format). Αυτό σημαίνει ότι το <a
href="dic.html">DIC</a> δεν μπορεί να δημιουργήσει εικονικούς δίσκους. Για τη δημιουργία αρχείων
ή εικόνων από τέτοια δισκέτα προτείνεται η χρήση του <a href="rawdic.html">RawDIC</a>.
Δείτε τις οδηγίες του RawDIC για περισσότερες πληροφορίες.
<h4>Πολλαπλές δισκέτες</h4>
Εάν το πρόγραμμα χρησιμοποιεί περισσότερες από μια δισκέτες το slave πρέπει να προωθήσει
τις προσβάσεις δισκετών στο κατάλληλο αρχείο εικόνας. Μερικές φορές αυτό δεν είναι εύκολο. Μερικά
προγράμματα υποστηρίζουν περισσότερους από έναν οδηγούς δισκέτας, οπότε μπορείτε να χρησιμοποιήσετε τον αριθμό του οδηγού
για την επιλογή της δισκέτας. Τα περισσότερα προγράμματα χρησιμοποιούν ένα ID σε κάθε δισκέτα για να τις ξεχωρίσουν.
Σε αυτή τη περίπτωση, χρησιμοποιούμε μια μεταβλητή που κρατάει τον αριθμό της δισκέτας, και σε κάθε πρόσβαση
στο ID της δισκέτας (καθορίζουμε τέτοια πρόσβαση αναλύοντας τις παραμέτρους για το
disk loader) αυξάνουμε τη μεταβλητή (αν φτάσουμε στη τελευταία δισκέτα, το μειώνουμε). Οπότε
ελπίζουμε ότι ο loader θα διαβάσει το ID ξανά και ξανά μέχρι να εισαχθεί
η σωστή δισκέτα. Ίσως υπάρχει ένα αίτημα από το πρόγραμμα για να εισάγει ο χρήστης
την κατάλληλη δισκέτα, απενεργοποιήστε το.
<h4>Αποθήκευση Highscore</h4>
Δεν υπάρχουν πολλά να πούμε εδώ. Χρησιμοποιούμε την <a
href="../autodoc.html#resload_SaveFile">resload_SaveFile</a> για να γράψουμε στη
κατάλληλη περιοχή μνήμης στη δισκέτα. Αν θέλετε, κρυπτογραφήστε τη ώστε οι χαμένοι να μην μπορούν
να τη διορθώσουν πολύ εύκολα. Δεν προτείνεται να γράψετε απευθείας σε εικονικούς δίσκους (χρησιμοποιώντας
<a href="../autodoc.html#resload_SaveFileOffset">resload_SaveFileOffset</a>), γιατί αν μερικές φορές
κάτι πάει στραβά (π.χ. κατάρρευση συστήματος) είναι πιθανόν τα εικονικά αρχεία να πάθουν
ζημιά.
<h4>Αποθήκευση παιχνιδιών (Savegames)</h4>
Ο χειρισμός αποθήκευσης παιχνιδιών είναι ο ίδιος με τα highscore.
<h4>Προσβάσεις στο λειτουργικό σύστημα</h4>
Στο χρόνο που εκτελείται το slave και το εγκατεστημένο πρόγραμμα, απολύτως κανένα λειτουργικό
δεν υπάρχει ή είναι προσβάσιμο ούτε έχει νόημα να προσπελάσουμε! Συνεπώς όλες
οι προσβάσεις που επιχειρούνται από το εγκατεστημένο πρόγραμμα πρέπει να απενεργοποιηθούν. Αν δεν υπάρχουν
πολλές, και δεν έχουν νόημα στο περιβάλλον του WHDLoad (όπως η
exec.Disable() ή exec.SuperState()) απλά κάντε τις NOP (<tt>$4e71</tt>). Αν οι προσβάσεις
έχουν κάποια σημαντική λειτουργία (όπως exec.DoIO()), προωθήστε τις στο Slave και
εξομοιώστε τις. Αν υπάρχουν πολλές, δημιουργήστε μια απλή simple exec.library σε μια
μη χρησιμοποιούμενη περιοχή μνήμης (εκκινήστε τη longword στη διεύθυνση <tt>$4</tt>). Μπορείτε να ελέγξετε
τον πηγαίο κώδικα για το Oscar.slave, που εξομοιώνει την
exec.AllocMem(). Για να εντοπίσετε προσβάσεις στο λειτουργικό, η αρχική execbase έχει οριστεί σε
<tt>$f0000001</tt> με την πρόθεση όλες οι ρουτίνες που χρησιμοποιούν την execbase
να δημιουργήσουν μια εξαίρεση "Address Error".<br>
Εάν υπάρχει βαριά χρήση λειτουργιών του λειτουργικού, χρησιμοποιούμε ένα από τα πακέτα kickemu που μπορούν
να βρεθούν στο πακέτο whdload-dev. Υπάρχει ένα πακέτο για Kick 1.3
('src/sources/whdload/kick13.s') και ένα για Kick 3.1 ('src/sources/whdload/kick31.s').
Αυτά τα πακέτα απαιτούν ένα αυθεντικό εικονικό αρχείο kickstart και θα δημιουργήσουν ένα πλήρες περιβάλλον λειτουργικού
μέσα στο χώρο του WHDLoad. Συμβουλευτείτε επίσης το κατάλληλο readme που δίνεται για περισσότερες
πληροφορίες.
<h3>Συχνά προβλήματα συμβατότητας</h3>
<h4>Περιορισμένος χώρος διευθύνσεων σε 68000/68010/68ec020</h4>
Σε αυτούς τους επεξεργαστές ο χώρος διευθύνσεων είναι περιορισμένος στα 16 MB (<tt>$000000...$ffffff</tt>)
γιατί αυτοί οι CPU έχουν μόνο 24 γραμμές διευθύνσεων. Σαν αποτέλεσμα όλες
οι προσβάσεις σε μεγαλύτερες διευθύνσεις γίνονται στα χαμηλότερα 16 MB αγνοώντας
τα πιο σημαντικά 8 bits. Μερικά προγράμματα χρησιμοποιούν αυτά τα bits για
να αποθηκεύουν δεδομένα, ή απλά ξεχνούν να τα καθαρίσουν. Σε έναν επεξεργαστή με πλήρες 4
GB χώρο διευθύνσεων όπως οι 68020/680ec30/68030/68040/68060 αυτό δεν θα λειτουργήσει,
γιατί θα προσπελαστεί ολόκληρη η διεύθυνση 32-bit.<br>
Για να το λύσουμε αυτό πρέπει να διορθώσουμε αυτές τις προσβάσεις και να τις προωθήσουμε στις κατάλληλες διευθύσεις.<br>
Μερικές φορές ο λόγος για προσβάσεις σε περίεργες διευθύνσεις μπορεί να είναι ένας μη αρχικοποιημένος δείκτης. Σε τέτοια περίπτωση μπορεί να βοηθήσει να καθαρίσουμε την <tt>$400</tt> - <a href="../autodoc.html#ws_BaseMemSize">ws_BaseMemSize</a>.
<h4>Διαφορετικά πλαίσια στοίβας (stackframes) σε κάθε επεξεργαστή</h4>
Τα πλαίσια στοίβας που δημιουργούνται από τον επεξεργαστή στις διακοπές (interrupts) και εξαιρέσεις
είναι διαφορετικά για τα μέλη της οικογένειας των 68k. Σε έναν 68000 ένα πλαίσιο στοίβας είναι 6
bytes, εκτός για Σφάλματα Διαύλου και Διευθύνσεων. Το πλαίσιο στοίβας περιέχει το αποθηκευμένο SR
στον (a7) και το αποθηκευμένο PC στον (2,a7). Σε όλους τους άλλους επεξεργαστές (68010+) το
ελάχιστο πλαίσιο στοίβας είναι 8 bytes και επιπλέον περιέχει τον αριθμό vector σαν
word στον (6,a7). Αυτή η μορφή Four-Word του πλαισίου στοίβας <tt>$0</tt> δημιουργείται για την "Trap #xx"
και τις διακοπές (Interrupts) σε 68010-68060. Τα πλαίσια στοίβας σε άλλες εξαιρέσεις είναι
διαφορετικά σε κάθε επεξεργαστή. Η εντολή RTE λειτουργεί διαφορετικά στον
68000 σε σύγκριση με τον 68010+. Σε έναν 68000 απλά επαναφέρει τον SR και PC και
συνεχίζει την εκτέλεση του προγράμματος στην διεύθυνση που είχε διακοπεί. Στον 68010+ θα
απελευθερώσει επιπλέον το πλαίσιο στοίβας ανάλογα την μορφή του πλαισίου στοίβας. <br>Μερικά
προγράμματα σπρώχνουν μια διεύθυνση (PC) και ένα SR και μετά εκτελούν μια εντολή RTE.
Αυτό δουλεύει μόνο σε έναν 68000, σε 68010+ αυτό θα έχει απροσδόκητα αποτελέσματα.
<br>Αν ένα πρόγραμμα το κάνει, θα πρέπει να το φτιάξουμε. Μερικές φορές ίσως είναι
αρκετό να αντικατασταθεί η RTE με ένα RTR.
<h4>MOVEM.x RL,-(An) σε 68000/010 και 68020-68060</h4>
Υπάρχει διαφορά αν ο καταχωρητής που θα χρησιμοποιηθεί σε predecrement mode (RL)
περιέχεται επίσης στη λίστα καταχωρητών. Για τους 68020-68060 η
τιμή που γράφεται στη μνήμη είναι η αρχική τιμή του καταχωρητή decremented από
μέγεθος της εργασίας. Οι 68000 και 68010 γράφουν την αρχική τιμή του καταχωρητή
(not decremented). <br>Επειδή μια τέτοια κατασκευή δεν είναι πολύ χρήσιμη, κανένα λογισμικό δεν είναι γνωστό να έχει προβλήματα λόγω αυτού.
<h3>Γενικές οδηγίες για εγγραφή εγκαταστάσεων</h3>
<ul>
<li>Μην αλλάζετε τους καταχωρητές CPU που υπάρχουν σε μεγαλύτερους επεξεργαστές όπως ο VBR ή ο
CACR. Ο VBR είναι πάντα 0 από την μεριά του προγραμματιστή του Slave, ακόμα και αν έχει
μετακινηθεί γιατί τα Auto Vectors (και τα Traps αν το Flag <a
href="../autodoc.html#WHDL_EmulTrap">WHDL_EmulTrap</a> is set) έχει οριστεί) εξομοιώνονται. Τα bits στον CACR 
είναι διαφορετικά για κάθε επεξεργαστή. Υπάρχει μόνο ένας έγκυρος τρόπος 
για την τροποποίηση της <a href="cache.html">προσωρινής μνήμης (caches)</a>, 
χρησιμοποιείστε <a href="../autodoc.html">resload_SetCACR/SetCPU</a> και τα bitdef's από την 'exec/execbase.i' και 'whdload.i'. Επίσης όλα τα πράγματα
που βρίσκονται στο πρόγραμμα προς εγκατάσταση που χτυπούν αυτούς τους καταχωρητές
πρέπει να απενεργοποιηθούν ή να παρακαμφθούν, διαφορετικά το WHDLoad δεν μπορεί να λειτουργήσει σωστά!
<li>Ποτέ μην τροποποιείτε εικονικούς δίσκους. Αυτό έχει το πλεονέκτημα ότι αν
κάποιος θέλει να ξεκινήσει το πρόγραμμα από δισκέτα το μόνο που έχει να κάνει
είναι να γράψει τα εικονικά αρχεία πίσω σε δισκέτα (με την προϋπόθεση ότι το πρόγραμμα τρέχει χωρίς
διάφορες διορθώσεις, σίγουρα όχι η πιο συχνή περίπτωση).
<li> Ποτέ μην χρησιμοποιείτε αυθεντικά πράγματα από το πρόγραμμα απευθείας στο slave (πρόβλημα πνευματικών δικαιωμάτων).
<li>Ενεργοποιήστε την προσωρινή μνήμη (Caches) μόνο αν είστε βέβαιοι ότι τρέχει σε όλους τους επεξεργαστές.
<li>Χρησιμοποιήστε όσο το δυνατόν λιγότερη μνήμη για την <a href="../autodoc.html#ws_BaseMemSize">ws_BaseMemSize</a>. Μερικοί
άνθρωποι έχουν μόνιμα στοιχεία (resident tags) στο τέλος της μνήμης Chip, οπότε βοηθάει να
χρησιμοποιήσετε μόνο <tt>$1f0000</tt> αντί για <tt>$200000</tt> και το WHDLoad μπορεί να χρησιμοποιήσει απόλυτη κατανεμημένη μνήμη.
</ul>
<h3>Συμβουλές &amp; κόλπα</h3>
<h4>Τι είναι καλύτερο, η χρήση εικονικών δίσκων ή αρχείων;</h4>
Μερικές φορές θα έχετε την επιλογή να χρησιμοποιήσετε εικονικούς δίσκους ή πραγματικά αρχεία. Και τα δύο
έχουν τα πλεονεκτήματά τους. Η χρήση των εικονικών δίσκων είναι συνήθως ο ευκολότερος και γρηγορότερος τρόπος
για τη δημιουργία του Slave. Αλλά τα πραγματικά αρχεία γίνονται πιο εύκολα αποθηκευμένα προσωρινά - cached (αν υπάρχει πολύ
λίγη μνήμη ή η μνήμη είναι κατακερματισμένη). Ο απαραίτητος
χώρος στο δίσκο θα είναι επίσης μικρότερος με πραγματικά αρχεία αντί για
εικονικά αρχεία. Χρησιμοποιήστε εικονικούς δίσκους μόνο αν υπάρχουν πολλά αρχεία (περισσότερα από
30).
</BODY>
</HTML>
