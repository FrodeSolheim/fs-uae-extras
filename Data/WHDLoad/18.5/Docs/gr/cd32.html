<HTML>
<HEAD>
<TITLE>WHDLoadCD32</TITLE>
<meta name="DC.Language" content="gr">
<meta http-equiv="content-language" content="gr">
<meta http-equiv="content-type" content="text/html; charset=iso-8859-7">
<!-- $Id: cd32.html 1.4 2015/04/19 21:08:08 wepl Exp wepl $ -->
</HEAD>
<BODY>

<h3>WHDLoadCD32</h3>

Το WHDLoadCD32 είναι μια ειδική έκδοση του WHDLoad για χρήση σε CD&sup3;&sup2;.
Έχει βελτιστοποιηθεί για αυτό το hardware και για αυτό τον λόγο θα τρέξει μόνο σε ένα απλό,
χωρίς επεκτάσεις CD&sup3;&sup2;. Δεν θα τρέξει σε SX-32 ή άλλο μηχάνημα.

<p>Αυτές είναι οι διαφορές από το απλό WHDLoad:
<ul>

<li>δεν απαιτεί ή χρησιμοποιεί WHDLoad keyfile, οπότε CD με το
WHDLoadCD32 μπορούν να διανέμονται ελεύθερα

<li>μόνο ο 68020 CPU υποστηρίζεται, αυτό σημαίνει επίσης ότι δεν υπάρχει υποστήριξη MMU

<li>η fast μνήμη δεν υποστηρίζεται

<li>δεν υπάρχει καθόλου υποστήριξη εγγραφής, ούτε savegames, highscores ούτε
coredumps (ένα CD είναι συνήθως μόνο για ανάγνωση)

<li>πολλές επιλογές που δεν χρειάζονται σε ένα CD&sup3;&sup2; έχουν αφαιρεθεί για
να γίνει μικρότερο το εκτελέσιμο αρχείο και για εξοικονόμηση μνήμης, δείτε το <a href="opt.html">Χρήση και
Επιλογές</a> για το ποιές επιλογές επηρρεάζονται

<li>οι ακόλουθες λειτουργίες resload δεν έχουν ενσωματοθεί και η χρήση τους θα
τερματίσει το WHDLoad με επιστρεφόμενη τιμή TDREASON_ILLEGALARGS:

<ul>
<li><a href="../autodoc.html#resload_DiskLoadDev">resload_DiskLoadDev</a>
<li><a href="../autodoc.html#resload_ProtectRead">resload_ProtectRead</a>
<li><a href="../autodoc.html#resload_ProtectReadWrite">resload_ProtectReadWrite</a>
<li><a href="../autodoc.html#resload_ProtectWrite">resload_ProtectWrite</a>
<li><a href="../autodoc.html#resload_ProtectRemove">resload_ProtectRemove</a>
<li><a href="../autodoc.html#resload_ProtectSMC">resload_ProtectSMC</a>
<li><a href="../autodoc.html#resload_Log">resload_Log</a>
</ul>

<li>οι ακόλουθες λειτουργίες resload είναι εικονικές, δεν θα κάνουν τίποτα αλλά
επιστρέφουν πάντα επιτυχία:

<ul>
<li><a href="../autodoc.html#resload_SaveFile">resload_SaveFile</a>
<li><a href="../autodoc.html#resload_SaveFileOffset">resload_SaveFileOffset</a>
<li><a href="../autodoc.html#resload_DeleteFile">resload_DeleteFile</a>
</ul>

<li>δεν υπάρχει καθόλου υποστήριξη <a href="freezer.html">παγώματος/επόπτη συστήματος</a> ενσωματομένη

<li>δεν υπάρχει καθόλου εσωτερικός έλεγχος για επαρκές μέγεθος στοίβας όπως στο κανονικό
WHDLoad, στις δοκιμές μου το προεπιλεγμένο μέγεθος των 4096 bytes πρέπει να είναι αρκετό για το WHDLoadCD32

</ul>

<h3>Συμβουλές για την χρήση του WHDLoad σε ένα CD&sup3;&sup2;</h3>

Το κυρίως πρόβλημα σε ένα CD&sup3;&sup2; είναι η περιορισμένη μνήμη. Υπάρχουν μόνο
2 MB chip μνήμης. Οπότε ο σκοπός πρέπει να είναι να έχουμε όσο το δυνατόν περισσότερη ελεύθερη
μνήμη για το WHDLoad και ειδικά για την λειτουργία Preload. Σιγουρευτείτε ότι κανένα άλλο
πρόγραμμα δεν τρέχει όταν ξεκινάτε ένα εγκατεστημένο πρόγραμμα με το
WHDLoadCD32.

<ul>

<li>Εάν η εγκατάσταση δίνει την επιλογή ανάμεσα σε εικονικούς δίσκους και αρχεία, χρησιμοποιήστε τα αρχεία. Επειδή
πολλά μικρότερα αρχεία μπορούν πιο εύκολα να μπουν στην cache από ότι μεγαλύτερα αρχεία.

<li>Εάν η εγκατάσταση παρέχει την δυνατότητα συμπίεσης αρχείων με ProPack/FImp χρησιμοποιήστε την
και συμπιέστε όλα τα αρχεία (το RNC1 έχει την καλύτερη συμπίεση). Τα συμπιεσμένα αρχεία
χρειάζονται λιγότερη μνήμη για την Preload και δεν καθυστερούν σχεδόν καθόλου το φόρτωμα.

<li>Χρησιμοποιήστε το AllocMemReverse πριν την εκτέλεση του WHDLoadCD32 (ή κάτι αντίστοιχου).
Το AllocMemReverse είναι ένα μικρό πρόγραμμα που συμπεριλαμβάνεται στο πακέτο-dev του WHDLoad.
Βάζει ένα patch στην λειτουργία exec AllocMem για να χρησιμοποιεί πάντα την ιδιότητα μνήμης
MEM_REVERSE για τις κατανομές. Αυτό θα προκαλέσει την κατανομή της μνήμης από την
κορυφή της ελεύθερης μνήμης προς την βάση όχι από την βάση προς την κορυφή ως συνήθως.
Και αυτό θα αφήσει τις χαμηλότερες περιοχές ελεύθερες. Η ιστορία είναι, ότι το
WHDLoad χρειάζεται μνήμη που να ξεκινάει στη διεύθυνση 0, την αρχή της chipmem. Όλη η μνήμη
που χρησιμοποιείται σε αυτή τη χαμηλότερη περιοχή πρέπει να μετακινηθεί. Για αυτό, επιπλέον
μνήμη χρειάζεται για να κρατήσει την μνήμη που μετακινείται. Όσο περισσότερη μνήμη χρησιμοποιείται
στις χαμηλότερες περιοχές μνήμης, τόσο λιγότερη είναι διαθέσιμη για το εγκατεστημένο πρόγραμμα
και για την προφόρτωση των αρχείων δεδομένων.

<li>Χρησιμοποιείτε πάντα την επιλογή <a href="opt.html#Data">Data</a>. Η Preload δεν γνωρίζει
ποιά αρχεία θα φορτωθούν από το εγκατεστημένο πρόγραμμα, οπότε φορτώνει όλα τα αρχεία που
θα βρεί. Για να αποφύγετε το φόρτωμα περιττών αρχείων δημιουργήστε έναν κατάλογο που
περιέχει μόνο τα απαραίτητα αρχεία. Διαγράψτε όλα τα άχρηστα πράγματα όπως #?.info,
#?.Slave, ReadMe, Manual κτλ. Μετά καλέστε το WHDLoad με τον κατάλογο Slave και Data
ως παράμετρο, π.χ. <tt>WHDLoadCD32 :Slaves/XYZ.Slave Data=:Data/XYZ Preload</tt>.
Δεν υπάρχει λόγος να αλλάξετε τον τρέχον κατάλογο πουθενά αλλού.

<li>Μην χρησιμοποιείτε αρχεία δεδομένων συμπιεσμένα με XPK. Η αποσυμπίεση XPK χρειάζεται πολύ μνήμη
γιατί οι βιβλιοθήκες XPK πρέπει να είναι στη μνήμη, ενώ η ίδια η αποσυμπίεση χρειάζεται μνήμη και
θα προκαλέσει κατακερματισμό της μνήμης.

</ul>
</BODY>
</HTML>
